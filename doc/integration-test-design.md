# 結合テスト設計書

## 分析結果サマリー

### 重要発見事項
1. **5つの主要状態オブジェクト**間の複雑な依存関係を特定
2. **3つの危険な結合ポイント**（状態不整合リスク箇所）を発見
3. **既存103テストの不足領域**：状態間連携の検証が薄い

### クリティカルな結合ポイント
1. **監視継続フラグ + 状態復元の60秒期限処理**
2. **カレンダー変更時の監視状態クリーンアップ連携**
3. **リロード時の複数状態同期**

## 最小限正常系結合テスト設計

### テスト戦略
- **クリティカルパス重点主義**: 影響の大きい状態遷移に集中
- **状態整合性チェック中心**: 複数状態の同期性を重点検証
- **実用シナリオベース**: 実際のユーザー操作パターンを模擬

### 必須結合テスト項目（優先度A）

#### 1. 監視設定→実行→復元の完全フロー
```
シナリオ: 新規監視対象設定から復元まで
1. multiTargetManager.addTarget() 
2. timeSlotState.mode = 'monitoring'
3. cacheManager.setMonitoringFlag(true)
4. ページリロード
5. cacheManager.getAndClearMonitoringFlag() → true
6. 状態復元確認
7. 監視継続確認

検証ポイント:
- 各状態オブジェクトの整合性
- キャッシュとメモリ状態の一致
- 監視フラグの正確な期限管理
```

#### 2. カレンダー変更時の状態クリーンアップ連携
```
シナリオ: 監視実行中のカレンダー変更
1. 監視状態設定（複数対象）
2. calendarWatchState.currentSelectedDate 変更検出
3. handleCalendarChange() 実行
4. 全状態のクリーンアップ確認

検証ポイント:
- multiTargetManager.clearAll() 実行
- timeSlotState.mode = 'idle' 設定
- cacheManager.clearTargetSlots() 実行
- FAB UI状態の同期更新
```

#### 3. リロード後の監視継続フラグ + 状態復元
```
シナリオ: 監視継続フラグ期限切れ処理
1. 監視フラグ設定（60秒期限）
2. 61秒後のページアクセス
3. 期限切れ検出処理
4. 状態初期化確認

検証ポイント:
- getAndClearMonitoringFlag() → false
- 全状態オブジェクトの初期値復元
- キャッシュクリア実行
```

### 重要結合テスト項目（優先度B）

#### 4. 予約実行中の状態変更制御
```
シナリオ: 予約実行中の他操作制御
1. entranceReservationState.isRunning = true
2. 監視操作試行
3. カレンダー変更試行
4. 制御確認

検証ポイント:
- 予約実行中の状態変更防止
- UI操作の適切な無効化
```

#### 5. FAB UI状態と内部状態の同期性
```
シナリオ: 状態変更後のUI反映
1. 各状態変更操作
2. updateMainButtonDisplay() 実行
3. UI表示と内部状態の一致確認

検証ポイント:
- getCurrentMode() の正確な判定
- FABボタン表示テキストの状態反映
- 監視対象表示の状態同期
```

## 実装計画

### Phase 1: 基盤準備
1. **共通ヘルパー関数作成**
   - 状態初期化ヘルパー
   - 状態検証アサーション関数
   - 時間系モック設定

### Phase 2: 必須テスト実装（優先度A）
2. **3つの必須結合テスト**の実装・実行
3. **状態整合性検証**の強化

### Phase 3: 重要テスト実装（優先度B）
4. **予約実行制御**・**UI同期性**テスト実装

### 期待される効果
- **分割作業リスク軽減**: 状態管理依存の事前検証
- **品質保証強化**: 現在未検証の結合部分をカバー
- **リファクタリング安全性**: 状態変更影響の迅速検出

## 次のアクション
**Phase 1基盤準備**から開始し、段階的に結合テストを実装します。