const entranceReservationConfig = {
    selectors: {
        submit: "#__next > div > div > main > div > div.style_main__add_cart_button__DCOw8 > button",
        change: "body > div > div > div > div > div > div > button",
        success: "#reservation_modal_title",
        failure: "#reservation_fail_modal_title",
        close: "body > div.style_buy-modal__1JZtS > div > div > div > div > ul > li > a"
    },
    selectorTexts: {
        change: "æ¥å ´æ—¥æ™‚ã‚’å¤‰æ›´ã™ã‚‹"
    },
    timeouts: {
        waitForSubmit: 5000,
        waitForResponse: 10000,
        waitForClose: 3000,
        retryInterval: 1000
    },
    randomSettings: {
        minCheckInterval: 500,
        checkRandomRange: 200,
        minClickDelay: 500,
        clickRandomRange: 200,
        minRetryDelay: 1000,
        retryRandomRange: 300
    }
};

function getRandomWaitTime(minTime, randomRange, config = entranceReservationConfig) {
    const { randomSettings } = config;
    const actualMinTime = minTime !== undefined ? minTime : randomSettings.minCheckInterval;
    const actualRandomRange = randomRange !== undefined ? randomRange : randomSettings.checkRandomRange;
    return actualMinTime + Math.floor(Math.random() * actualRandomRange);
}

async function waitForElement(selector, timeout = 5000, config = entranceReservationConfig) {
    return new Promise((resolve, reject) => {
        const startTime = Date.now();
        
        const checkElement = () => {
            const element = document.querySelector(selector);
            if (element) {
                resolve(element);
            } else if (Date.now() - startTime > timeout) {
                reject(new Error(`è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${selector}`));
            } else {
                setTimeout(checkElement, getRandomWaitTime(config.randomSettings.minCheckInterval, config.randomSettings.checkRandomRange, config));
            }
        };
        
        checkElement();
    });
}

async function waitForAnyElement(selectors, timeout = 10000, selectorTexts = {}, config = entranceReservationConfig) {
    return new Promise((resolve, reject) => {
        const startTime = Date.now();
        
        const checkElements = () => {
            for (const [key, selector] of Object.entries(selectors)) {
                const elements = document.querySelectorAll(selector);
                
                for (const element of elements) {
                    if (selectorTexts[key]) {
                        if (element.textContent && element.textContent.includes(selectorTexts[key])) {
                            resolve({ key, element });
                            return;
                        }
                    } else {
                        if (element) {
                            resolve({ key, element });
                            return;
                        }
                    }
                }
            }
            
            if (Date.now() - startTime > timeout) {
                reject(new Error(`ã„ãšã‚Œã®è¦ç´ ã‚‚è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${Object.keys(selectors).join(', ')}`));
            } else {
                setTimeout(checkElements, getRandomWaitTime(config.randomSettings.minCheckInterval, config.randomSettings.checkRandomRange, config));
            }
        };
        
        checkElements();
    });
}

async function clickElement(element, config = entranceReservationConfig) {
    element.click();
    const delay = getRandomWaitTime(config.randomSettings.minClickDelay, config.randomSettings.clickRandomRange, config);
    await new Promise(resolve => setTimeout(resolve, delay));
}

let reservationState = {
    isRunning: false,
    shouldStop: false
};

function createReservationUI() {
    const targetDiv = document.querySelector('#__next > div > div > main > div > div.style_main__prev_button__gJ5ZR');
    if (!targetDiv) {
        console.error('UIæŒ¿å…¥å¯¾è±¡ã®divãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
        return;
    }

    const controlDiv = document.createElement('div');
    controlDiv.style.display = 'flex';
    controlDiv.style.gap = '10px';
    controlDiv.style.margin = '10px 0';
    controlDiv.id = 'entrance-reservation-controls';

    const startButton = document.createElement('button');
    startButton.classList.add('basic-btn', 'type2', 'no-after', 'ext-ytomo');
    startButton.style.height = 'auto';
    startButton.style.minHeight = '40px';
    startButton.style.width = 'auto';
    startButton.style.minWidth = '60px';
    startButton.style.padding = '0px 8px';
    startButton.style.background = 'rgb(0, 104, 33)';
    startButton.style.color = 'white';
    startButton.style.margin = '5px';
    
    const startSpan = document.createElement('span');
    startSpan.classList.add('ext-ytomo');
    startSpan.innerText = 'ç¹°ã‚Šè¿”ã—äºˆç´„try';
    startButton.appendChild(startSpan);

    const stopButton = document.createElement('button');
    stopButton.classList.add('basic-btn', 'type2', 'no-after', 'ext-ytomo');
    stopButton.style.height = 'auto';
    stopButton.style.minHeight = '40px';
    stopButton.style.width = 'auto';
    stopButton.style.minWidth = '60px';
    stopButton.style.padding = '0px 8px';
    stopButton.style.background = 'rgb(74, 76, 74)';
    stopButton.style.color = 'white';
    stopButton.style.margin = '5px';
    stopButton.disabled = true;
    
    const stopSpan = document.createElement('span');
    stopSpan.classList.add('ext-ytomo');
    stopSpan.innerText = 'ç¹°ã‚Šè¿”ã—ã‚­ãƒ£ãƒ³ã‚»ãƒ«';
    stopButton.appendChild(stopSpan);

    const statusDiv = document.createElement('div');
    statusDiv.style.padding = '5px';
    statusDiv.style.fontSize = '14px';
    statusDiv.style.color = '#666';
    statusDiv.id = 'reservation-status';
    statusDiv.innerText = 'å¾…æ©Ÿä¸­';

    startButton.addEventListener('click', async () => {
        if (reservationState.isRunning) return;
        
        reservationState.isRunning = true;
        reservationState.shouldStop = false;
        startButton.disabled = true;
        stopButton.disabled = false;
        startButton.style.background = 'rgb(74, 76, 74)';
        statusDiv.innerText = 'äºˆç´„å‡¦ç†å®Ÿè¡Œä¸­...';
        
        try {
            const result = await entranceReservationHelper();
            if (result.success) {
                statusDiv.innerText = `ğŸ‰ äºˆç´„æˆåŠŸï¼(${result.attempts}å›è©¦è¡Œ)`;
                statusDiv.style.color = 'green';
            } else {
                statusDiv.innerText = `äºˆç´„å¤±æ•— (${result.attempts}å›è©¦è¡Œ)`;
                statusDiv.style.color = 'red';
            }
        } catch (error) {
            console.error('äºˆç´„å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
            statusDiv.innerText = `ã‚¨ãƒ©ãƒ¼: ${error.message}`;
            statusDiv.style.color = 'red';
        } finally {
            reservationState.isRunning = false;
            startButton.disabled = false;
            stopButton.disabled = true;
            startButton.style.background = 'rgb(0, 104, 33)';
        }
    });

    stopButton.addEventListener('click', () => {
        reservationState.shouldStop = true;
        statusDiv.innerText = 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«ä¸­...';
        statusDiv.style.color = 'orange';
    });

    controlDiv.appendChild(startButton);
    controlDiv.appendChild(stopButton);
    controlDiv.appendChild(statusDiv);
    targetDiv.appendChild(controlDiv);
    
    console.log('äºˆç´„åˆ¶å¾¡UIã‚’æŒ¿å…¥ã—ã¾ã—ãŸ');
}

async function entranceReservationHelper(config = entranceReservationConfig) {
    const { selectors, selectorTexts, timeouts } = config;
    let attempts = 0;
    const maxAttempts = 100;
    
    console.log('å…¥å ´äºˆç´„è£œåŠ©æ©Ÿèƒ½ã‚’é–‹å§‹ã—ã¾ã™...');
    
    while (attempts < maxAttempts && !reservationState.shouldStop) {
        attempts++;
        console.log(`è©¦è¡Œå›æ•°: ${attempts}`);
        
        const statusDiv = document.getElementById('reservation-status');
        if (statusDiv) {
            statusDiv.innerText = `è©¦è¡Œä¸­... (${attempts}å›ç›®)`;
        }
        
        try {
            console.log('1. submitãƒœã‚¿ãƒ³ã‚’å¾…æ©Ÿä¸­...');
            const submitButton = await waitForElement(selectors.submit, timeouts.waitForSubmit, config);
            
            if (reservationState.shouldStop) break;
            
            console.log('submitãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™ã€‚');
            await clickElement(submitButton, config);
            
            console.log('2. ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å¾…æ©Ÿä¸­...');
            const responseSelectors = {
                change: selectors.change,
                success: selectors.success,
                failure: selectors.failure
            };
            
            const response = await waitForAnyElement(responseSelectors, timeouts.waitForResponse, selectorTexts, config);
            console.log(`ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ¤œå‡º: ${response.key}`);
            
            if (reservationState.shouldStop) break;
            
            if (response.key === 'change') {
                console.log('changeãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™ã€‚');
                await clickElement(response.element, config);
                
                console.log('success/failureã‚’å¾…æ©Ÿä¸­...');
                const finalSelectors = {
                    success: selectors.success,
                    failure: selectors.failure
                };
                
                const finalResponse = await waitForAnyElement(finalSelectors, timeouts.waitForResponse, selectorTexts, config);
                console.log(`æœ€çµ‚ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ¤œå‡º: ${finalResponse.key}`);
                
                if (finalResponse.key === 'success') {
                    console.log('ğŸ‰ äºˆç´„æˆåŠŸï¼å‡¦ç†ã‚’çµ‚äº†ã—ã¾ã™ã€‚');
                    return { success: true, attempts };
                } else {
                    console.log('äºˆç´„å¤±æ•—ã€‚closeãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦å†è©¦è¡Œã—ã¾ã™ã€‚');
                    const closeButton = await waitForElement(selectors.close, timeouts.waitForClose, config);
                    await clickElement(closeButton, config);
                    await new Promise(resolve => setTimeout(resolve, getRandomWaitTime(config.randomSettings.minRetryDelay, config.randomSettings.retryRandomRange, config)));
                }
            } else if (response.key === 'success') {
                console.log('ğŸ‰ äºˆç´„æˆåŠŸï¼å‡¦ç†ã‚’çµ‚äº†ã—ã¾ã™ã€‚');
                return { success: true, attempts };
            } else if (response.key === 'failure') {
                console.log('äºˆç´„å¤±æ•—ã€‚closeãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦å†è©¦è¡Œã—ã¾ã™ã€‚');
                const closeButton = await waitForElement(selectors.close, timeouts.waitForClose, config);
                await clickElement(closeButton, config);
                await new Promise(resolve => setTimeout(resolve, getRandomWaitTime(config.randomSettings.minRetryDelay, config.randomSettings.retryRandomRange, config)));
            }
            
        } catch (error) {
            console.error(`ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ (è©¦è¡Œ ${attempts}):`, error.message);
            if (reservationState.shouldStop) break;
            await new Promise(resolve => setTimeout(resolve, getRandomWaitTime(config.randomSettings.minRetryDelay, config.randomSettings.retryRandomRange, config)));
        }
    }
    
    if (reservationState.shouldStop) {
        console.log('ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã£ã¦ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚');
        return { success: false, attempts, cancelled: true };
    }
    
    console.log(`æœ€å¤§è©¦è¡Œå›æ•° (${maxAttempts}) ã«é”ã—ã¾ã—ãŸã€‚å‡¦ç†ã‚’çµ‚äº†ã—ã¾ã™ã€‚`);
    return { success: false, attempts };
}

setTimeout(() => {
    createReservationUI();
}, 1000);

console.log('å…¥å ´äºˆç´„è£œåŠ©æ©Ÿèƒ½ãŒãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã—ãŸã€‚');
console.log('UIãƒœã‚¿ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã€æ‰‹å‹•å®Ÿè¡Œ: entranceReservationHelper()');
console.log('è¨­å®šã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ã«ã¯: entranceReservationHelper(yourConfig)');