/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src-modules/section1.ts":
/*!*********************************!*\
  !*** ./src-modules/section1.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("{\n// 【1. 基本機能・ユーティリティ】\n// ============================================================================\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init_entrance_page = exports.judge_entrance_init = exports.judge_init = exports.init_page = exports.prepare_filter = exports.insert_style = void 0;\nexports.getRandomWaitTime = getRandomWaitTime;\nexports.waitForElement = waitForElement;\nexports.waitForAnyElement = waitForAnyElement;\nexports.clickElement = clickElement;\n// スタイルを挿入する関数\nconst insert_style = () => {\n    const style = document.createElement(\"style\");\n    style.innerHTML = `\nbutton.ext-ytomo {\n    height: 40px;\n    width: auto;\n    min-width: 60px;\n    padding: 0px 8px;\n    background: rgb(0, 104, 33) !important;\n    color: white;\n}\nbutton.no-after.ext-ytomo:after {\n    background: transparent none repeat 0 0 / auto auto padding-box border-box scroll;\n}\nbutton.ext-ytomo.btn-done {\n    background: rgb(74, 76, 74) !important;\n}\n.ext-ytomo:hover {\n    background: rgb(2, 134, 43);\n}\n\n.safe-none, .ytomo-none, .filter-none {\n    display: none;\n}\n\ndiv.div-flex {\n    display: flex;\n    justify-content: center;\n    margin: 5px;\n}\n\ninput.ext-tomo.search {\n    height: 50px;\n    min-width: 200px;\n    max-width: min(300px, 100%);\n    font-family: quicksand;\n    font-size: 16px;\n    -webkit-appearance: textfield;\n    -moz-appearance: textfield;\n    appearance: textfield;\n    border: 1px solid #222426;\n    border-radius: 25px;\n    box-shadow: 0 1px 0 0 #ccc;\n    padding: 0 0 0 10px;\n    flex: 1 1;\n}\n    `;\n    document.head.appendChild(style);\n};\nexports.insert_style = insert_style;\n// 検索ワードを正規表現に変換する関数\n// val_searchには以下の3種類に大別されるワードが含まれる\n// 1. 通常の文字列\n// 2. マイナス検索用文字列 (`-`から始まる)\n// 3. phrase検索用文字列 (`\"`で囲まれた文字列)\n// また、*は0文字以上のワイルドカードとして扱う\n// 区切り文字は以下の通り\n// 1. 全角スペース, 半角スペース: ANDの意味\n// 2. or, OR (前後に全角または半角の空白を伴う): ORの意味\n// また、ANDやORを組み合わせる場合、半角括弧でその範囲を明示的にできる\nconst prepare_filter = (val_search) => {\n    // 空の検索文字列の場合は全てにマッチする正規表現を返す\n    if (!val_search.trim()) {\n        return { include: /(?:)/, exclude: null };\n    }\n    // OR条件を一時的に特別なマーカーに置換（後で処理するため）\n    const orReplaced = val_search.replace(/(?:\\s+|^)(or|OR)(?:\\s+|$)/g, ' \\uFFFF ');\n    // フレーズ検索（引用符で囲まれた部分）を抽出\n    const phraseMatches = orReplaced.match(/\"[^\"]*\"/g) || [];\n    let remainingStr = orReplaced;\n    const phrases = phraseMatches.map(phrase => {\n        remainingStr = remainingStr.replace(phrase, '');\n        return phrase.slice(1, -1).replace(/\\*/g, '.*');\n    });\n    // 残りの部分から通常の単語とマイナス検索を抽出\n    const tokens = remainingStr.split(/\\s+/).filter(token => token);\n    const includeTokens = [];\n    const excludeTokens = [];\n    tokens.forEach(token => {\n        if (token === '\\uFFFF') {\n            // ORマーカー\n            includeTokens.push(token);\n        }\n        else if (token.startsWith('-')) {\n            // マイナス検索\n            const cleaned = token.slice(1).replace(/\\*/g, '.*');\n            if (cleaned)\n                excludeTokens.push(cleaned);\n        }\n        else {\n            // 通常の検索\n            const cleaned = token.replace(/\\*/g, '.*');\n            if (cleaned)\n                includeTokens.push(cleaned);\n        }\n    });\n    // フレーズをincludeTokensに追加\n    phrases.forEach(phrase => {\n        includeTokens.push(phrase);\n    });\n    const processParentheses = (tokens) => {\n        const stack = [[]];\n        for (const token of tokens) {\n            if (token === '(') {\n                stack.push([]);\n            }\n            else if (token === ')') {\n                if (stack.length > 1) {\n                    const group = stack.pop();\n                    stack[stack.length - 1].push(group);\n                }\n            }\n            else {\n                stack[stack.length - 1].push(token);\n            }\n        }\n        return stack[0];\n    };\n    const groupedIncludes = processParentheses(includeTokens);\n    // 正規表現の構築（順不同対応版）\n    const buildRegex = (group) => {\n        if (Array.isArray(group)) {\n            const parts = group.map(item => Array.isArray(item) ? buildRegex(item) : item);\n            // ORマーカーがあるかチェック\n            const orIndex = parts.findIndex((part) => part === '\\uFFFF');\n            if (orIndex > -1) {\n                const left = buildRegex(parts.slice(0, orIndex));\n                const right = buildRegex(parts.slice(orIndex + 1));\n                return `(?:${left}|${right})`;\n            }\n            else {\n                // AND条件の場合は順不同でマッチするように変更\n                return parts.map((part) => `(?=.*${part})`).join('');\n            }\n        }\n        return group;\n    };\n    const includePattern = buildRegex(groupedIncludes)\n        .replace(/\\uFFFF/g, '|')\n        .replace(/\\.\\*/g, '[\\\\s\\\\S]*');\n    // Safari対応：除外条件を別々にチェックする方式に変更\n    const excludePatterns = excludeTokens.map(token => new RegExp(token.replace(/\\.\\*/g, '[\\\\s\\\\S]*'), 'i'));\n    return {\n        include: new RegExp(includePattern, 'i'),\n        exclude: excludePatterns.length > 0 ? excludePatterns : null\n    };\n};\nexports.prepare_filter = prepare_filter;\n// ページ初期化処理\nconst init_page = () => {\n    // すべて読み込みボタンの自動クリック処理\n    const load_more_auto = async () => {\n        const scrollX = window.scrollX;\n        const scrollY = window.scrollY;\n        const arr_btn = document.querySelectorAll(\"button.style_more_btn__ymb22:not([disabled])\");\n        if (arr_btn.length > 0) {\n            arr_btn[0].click();\n            setTimeout(() => {\n                scrollTo(scrollX, scrollY);\n                load_more_auto();\n            }, 500);\n        }\n        else {\n            console.log(\"No more load more button\");\n        }\n    };\n    // ボタンのスタイルを生成する関数\n    const get_btn_style = () => {\n        const btn = document.createElement(\"button\");\n        btn.classList.add(\"basic-btn\");\n        btn.classList.add(\"type2\");\n        btn.classList.add(\"no-after\");\n        btn.classList.add(\"ext-ytomo\");\n        btn.style.height = \"auto\";\n        btn.style.minHeight = \"40px\";\n        btn.style.width = \"auto\";\n        btn.style.minWidth = \"60px\";\n        btn.style.padding = \"0px 8px\";\n        // btn.style.background = \"rgb(0, 104, 33)\";\n        btn.style.color = \"white\";\n        btn.style.margin = \"5px\";\n        return btn;\n    };\n    // 独自ボタン群を挿入する関数\n    const insert_button = () => {\n        // const btn_official_search = document.querySelector(\"button.style_search_btn__ZuOpx\");\n        const div_official_search = document.querySelector(\"div.style_search__7HKSe\");\n        const div_insert = document.createElement(\"div\");\n        div_insert.classList.add(\"div-flex\");\n        const div_insert2 = document.createElement(\"div\");\n        div_insert2.classList.add(\"div-flex\");\n        const btn_load_all = get_btn_style();\n        btn_load_all.classList.add(\"btn-load-all\");\n        const span_load_all = document.createElement(\"span\");\n        span_load_all.classList.add(\"ext-ytomo\");\n        span_load_all.innerText = \"すべて読み込み\";\n        btn_load_all.appendChild(span_load_all);\n        const btn_filter_safe = get_btn_style();\n        btn_filter_safe.classList.add(\"btn-filter-safe\");\n        const span_filter_safe = document.createElement(\"span\");\n        span_filter_safe.classList.add(\"ext-ytomo\");\n        span_filter_safe.innerText = \"空きのみ\";\n        btn_filter_safe.appendChild(span_filter_safe);\n        const btn_filter_without_load = get_btn_style();\n        btn_filter_without_load.classList.add(\"btn-filter-without-load\");\n        const span_filter_without_load = document.createElement(\"span\");\n        span_filter_without_load.classList.add(\"ext-ytomo\");\n        span_filter_without_load.innerText = \"絞込\";\n        btn_filter_without_load.appendChild(span_filter_without_load);\n        const input_another_search = document.createElement(\"input\");\n        input_another_search.classList.add(\"ext-tomo\");\n        input_another_search.classList.add(\"search\");\n        input_another_search.setAttribute(\"type\", \"text\");\n        input_another_search.setAttribute(\"placeholder\", \"読み込みなし絞込\");\n        const btn_alert_to_copy = get_btn_style();\n        btn_alert_to_copy.classList.add(\"btn-alert-to-copy\");\n        const span_alert_to_copy = document.createElement(\"span\");\n        span_alert_to_copy.classList.add(\"ext-ytomo\");\n        span_alert_to_copy.innerText = \"一覧コピー\";\n        btn_alert_to_copy.appendChild(span_alert_to_copy);\n        // btn_official_search.after(btn_filter_safe);\n        // btn_official_search.after(btn_load_all);\n        // btn_official_search.after(btn_filter_without_load);\n        div_insert.appendChild(input_another_search);\n        div_insert.appendChild(btn_filter_without_load);\n        div_insert2.appendChild(btn_load_all);\n        div_insert2.appendChild(btn_filter_safe);\n        div_insert2.appendChild(btn_alert_to_copy);\n        if (div_official_search) {\n            div_official_search.after(div_insert);\n            div_official_search.after(div_insert2);\n        }\n    };\n    // const refresh_btn_ = () => {\n    // }\n    insert_style();\n    insert_button();\n    // 独自ボタンのクリックイベントハンドラ\n    document.addEventListener(\"click\", (event) => {\n        if (event.target?.matches?.(\"button.ext-ytomo, button.ext-ytomo *\")) {\n            // event.preventDefault()\n            // event.stopPropagation()\n            const target = event.target?.closest?.(\"button.ext-ytomo\");\n            if (target && target.classList.contains(\"btn-load-all\")) {\n                // すべて読み込み\n                target.disabled = true;\n                load_more_auto().then(() => {\n                    if (target) {\n                        target.disabled = false;\n                        target.classList.toggle(\"btn-done\");\n                    }\n                });\n            }\n            else if (target && target.classList.contains(\"btn-filter-safe\")) {\n                // 空きあり絞り込み\n                target.disabled = true;\n                target.classList.toggle(\"btn-done\");\n                document.querySelectorAll(\"div.style_search_item_row__moqWC:has(img[src*=\\\"/asset/img/calendar_none.svg\\\"])\").forEach((div) => {\n                    div.classList.toggle(\"safe-none\");\n                });\n                setTimeout(() => {\n                    if (target) {\n                        target.disabled = false;\n                    }\n                }, 500);\n            }\n            else if (target && target.classList.contains(\"btn-filter-without-load\")) {\n                // 入力値で絞り込み\n                target.disabled = true;\n                const input_another_search = document.querySelector(\"input.ext-tomo.search\");\n                const arr_div_row = document.querySelectorAll(\"div.style_search_item_row__moqWC\");\n                const val_search = input_another_search?.value || '';\n                const dic_regex_exp = prepare_filter(val_search);\n                if (val_search.length > 0) {\n                    arr_div_row.forEach((div) => {\n                        div.classList.remove(\"filter-none\");\n                        if (!((dic_regex_exp.include === null || dic_regex_exp.include.test(div.innerText))\n                            && (dic_regex_exp.exclude === null || !dic_regex_exp.exclude.some((d) => d.test(div.innerText))))) {\n                            div.classList.add(\"filter-none\");\n                        }\n                    });\n                }\n                else {\n                    arr_div_row.forEach((div) => {\n                        div.classList.remove(\"filter-none\");\n                    });\n                }\n                // setTimeout(() => {\n                if (target) {\n                    target.disabled = false;\n                }\n                // }, 500)\n            }\n            else if (target && target.classList.contains(\"btn-alert-to-copy\")) {\n                // 一覧コピー\n                target.disabled = true;\n                // アラート起動\n                // filter-none, ytomo-none, safe-noneを除外して表示\n                const arr_div_row = document.querySelectorAll(\"div.style_search_item_row__moqWC:not(.filter-none):not(.ytomo-none):not(.safe-none)\");\n                let arr_text = [];\n                // div > button > span のテキストを取得\n                arr_div_row.forEach((div) => {\n                    const span = div.querySelector(\"button>span\");\n                    if (span) {\n                        arr_text.push(span.innerText);\n                    }\n                });\n                const text = arr_text.join(\"\\n\");\n                try {\n                    navigator.clipboard.writeText(text);\n                }\n                catch (e) {\n                    alert(text);\n                    // console.error(\"ytomo extension error\", e);\n                    // alert(e);\n                }\n                setTimeout(() => {\n                    target.disabled = false;\n                }, 500);\n            }\n        }\n    });\n};\nexports.init_page = init_page;\n// ページ初期化可能か判定\nconst judge_init = () => {\n    const cand_btn = document.querySelector(\"button.style_search_btn__ZuOpx\");\n    return cand_btn !== null;\n};\nexports.judge_init = judge_init;\n// 入場予約ページ初期化可能か判定\nconst judge_entrance_init = () => {\n    const target_div = document.querySelector('#__next > div > div > main > div > div.style_main__prev_button__gJ5ZR');\n    return target_div !== null;\n};\nexports.judge_entrance_init = judge_entrance_init;\n// 入場予約ページ初期化処理\nconst init_entrance_page = (dependencies = {}) => {\n    const { setPageLoadingStateFn, createEntranceReservationUIFn, initTimeSlotMonitoringFn, restoreFromCacheFn } = dependencies;\n    insert_style();\n    // 入場予約機能の設定\n    const entranceReservationConfig = {\n        selectors: {\n            submit: \"#__next > div > div > main > div > div.style_main__add_cart_button__DCOw8 > button\",\n            change: \"body > div > div > div > div > div > div > button\",\n            success: \"#reservation_modal_title\",\n            failure: \"#reservation_fail_modal_title\",\n            close: \"body > div.style_buy-modal__1JZtS > div > div > div > div > ul > li > a\"\n        },\n        selectorTexts: {\n            change: \"来場日時を変更する\"\n        },\n        timeouts: {\n            waitForSubmit: 5000,\n            waitForResponse: 10000,\n            waitForClose: 3000,\n            retryInterval: 1000\n        },\n        randomSettings: {\n            minCheckInterval: 500,\n            checkRandomRange: 200,\n            minClickDelay: 500,\n            clickRandomRange: 200,\n            minRetryDelay: 1000,\n            retryRandomRange: 300\n        }\n    };\n    // 初期化開始時に即座に読み込み状態を設定\n    if (setPageLoadingStateFn)\n        setPageLoadingStateFn(true);\n    // UIを即座に作成（読み込み状態表示のため）\n    if (createEntranceReservationUIFn)\n        createEntranceReservationUIFn(entranceReservationConfig);\n    // 時間帯監視機能の初期化（動的待機）\n    (async () => {\n        if (initTimeSlotMonitoringFn)\n            await initTimeSlotMonitoringFn();\n        // キャッシュからの状態復元（カレンダー読み込み完了後に実行）\n        if (restoreFromCacheFn)\n            await restoreFromCacheFn();\n        // 初期化完了時に読み込み状態を解除\n        if (setPageLoadingStateFn)\n            setPageLoadingStateFn(false);\n    })();\n    console.log(\"入場予約機能の初期化完了\");\n};\nexports.init_entrance_page = init_entrance_page;\n// 入場予約関連のヘルパー関数\nfunction getRandomWaitTime(minTime, randomRange, config) {\n    const { randomSettings } = config;\n    const actualMinTime = minTime !== undefined ? minTime : randomSettings.minCheckInterval;\n    const actualRandomRange = randomRange !== undefined ? randomRange : randomSettings.checkRandomRange;\n    return actualMinTime + Math.floor(Math.random() * actualRandomRange);\n}\nasync function waitForElement(selector, timeout = 5000, config) {\n    return new Promise((resolve, reject) => {\n        const startTime = Date.now();\n        const checkElement = () => {\n            const element = document.querySelector(selector);\n            if (element) {\n                resolve(element);\n            }\n            else if (Date.now() - startTime > timeout) {\n                reject(new Error(`要素が見つかりません: ${selector}`));\n            }\n            else {\n                setTimeout(checkElement, getRandomWaitTime(config.randomSettings.minCheckInterval, config.randomSettings.checkRandomRange, config));\n            }\n        };\n        checkElement();\n    });\n}\nasync function waitForAnyElement(selectors, timeout = 10000, selectorTexts = {}, config) {\n    return new Promise((resolve, reject) => {\n        const startTime = Date.now();\n        const checkElements = () => {\n            for (const [key, selector] of Object.entries(selectors)) {\n                const elements = document.querySelectorAll(selector);\n                for (let i = 0; i < elements.length; i++) {\n                    const element = elements[i];\n                    if (selectorTexts[key]) {\n                        if (element.textContent && element.textContent.includes(selectorTexts[key])) {\n                            resolve({ key, element: element });\n                            return;\n                        }\n                    }\n                    else {\n                        if (element) {\n                            resolve({ key, element: element });\n                            return;\n                        }\n                    }\n                }\n            }\n            if (Date.now() - startTime > timeout) {\n                reject(new Error(`いずれの要素も見つかりません: ${Object.keys(selectors).join(', ')}`));\n            }\n            else {\n                setTimeout(checkElements, getRandomWaitTime(config.randomSettings.minCheckInterval, config.randomSettings.checkRandomRange, config));\n            }\n        };\n        checkElements();\n    });\n}\nasync function clickElement(element, config) {\n    element.click();\n    const delay = getRandomWaitTime(config.randomSettings.minClickDelay, config.randomSettings.clickRandomRange, config);\n    await new Promise(resolve => setTimeout(resolve, delay));\n}\n\n\n//# sourceURL=webpack://expo2025-extension/./src-modules/section1.ts?\n}");

/***/ }),

/***/ "./src-modules/section2.ts":
/*!*********************************!*\
  !*** ./src-modules/section2.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("{\n// ============================================================================\n// 【2. 状態管理オブジェクト】\n// ============================================================================\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.calendarWatchState = exports.reloadCountdownState = exports.pageLoadingState = exports.multiTargetManager = exports.timeSlotState = exports.entranceReservationState = void 0;\nlet entranceReservationState = {\n    isRunning: false,\n    shouldStop: false,\n    startTime: null,\n    attempts: 0\n};\nexports.entranceReservationState = entranceReservationState;\n// 時間帯監視機能の状態管理\nlet timeSlotState = {\n    mode: 'idle', // idle, selecting, monitoring, trying\n    targetSlots: [], // 複数選択対象の時間帯情報配列\n    monitoringInterval: null, // 監視用インターバル\n    isMonitoring: false,\n    retryCount: 0,\n    maxRetries: 100,\n    reloadInterval: 30000 // 30秒間隔\n};\nexports.timeSlotState = timeSlotState;\n// 複数監視対象管理のヘルパー関数\nconst multiTargetManager = {\n    // 監視対象を追加\n    addTarget(slotInfo) {\n        // 時間+位置（東西）で一意性を判定\n        const existingIndex = timeSlotState.targetSlots.findIndex(slot => slot.timeText === slotInfo.timeText &&\n            slot.tdSelector === slotInfo.tdSelector);\n        if (existingIndex === -1) {\n            timeSlotState.targetSlots.push(slotInfo);\n            // 位置情報を含めたログ出力\n            const locationInfo = this.getLocationFromSelector(slotInfo.tdSelector);\n            console.log(`✅ 監視対象を追加: ${slotInfo.timeText} ${locationInfo} (総数: ${timeSlotState.targetSlots.length})`);\n            return true;\n        }\n        else {\n            const locationInfo = this.getLocationFromSelector(slotInfo.tdSelector);\n            console.log(`⚠️ 監視対象は既に選択済み: ${slotInfo.timeText} ${locationInfo}`);\n            return false;\n        }\n    },\n    // 監視対象を削除（時間+位置で特定）\n    removeTarget(timeText, tdSelector) {\n        const initialLength = timeSlotState.targetSlots.length;\n        timeSlotState.targetSlots = timeSlotState.targetSlots.filter(slot => !(slot.timeText === timeText && slot.tdSelector === tdSelector));\n        // 削除された場合の処理\n        if (timeSlotState.targetSlots.length < initialLength) {\n            const locationInfo = this.getLocationFromSelector(tdSelector);\n            console.log(`✅ 監視対象を削除: ${timeText} ${locationInfo} (残り: ${timeSlotState.targetSlots.length})`);\n            return true;\n        }\n        return false;\n    },\n    // 監視対象をすべてクリア\n    clearAll() {\n        const count = timeSlotState.targetSlots.length;\n        timeSlotState.targetSlots = [];\n        console.log(`✅ すべての監視対象をクリア (${count}個)`);\n    },\n    // 監視対象が存在するかチェック\n    hasTargets() {\n        return timeSlotState.targetSlots.length > 0;\n    },\n    // 特定の監視対象が選択済みかチェック（時間+位置）\n    isSelected(timeText, tdSelector) {\n        return timeSlotState.targetSlots.some(slot => slot.timeText === timeText && slot.tdSelector === tdSelector);\n    },\n    // 監視対象のリストを取得\n    getTargets() {\n        return [...timeSlotState.targetSlots];\n    },\n    // 監視対象の数を取得\n    getCount() {\n        return timeSlotState.targetSlots.length;\n    },\n    // tdSelectorから位置情報（東西）を推定\n    getLocationFromSelector(tdSelector) {\n        if (!tdSelector)\n            return '不明';\n        // nth-child の値から東西を推定\n        // 同じ時間の場合、0番目が東、1番目が西という仕様\n        const cellMatch = tdSelector.match(/td:nth-child\\((\\d+)\\)/);\n        if (cellMatch && cellMatch[1]) {\n            const cellIndex = parseInt(cellMatch[1]) - 1; // nth-childは1ベース\n            if (cellIndex === 0)\n                return '東';\n            if (cellIndex === 1)\n                return '西';\n        }\n        return '不明';\n    }\n};\nexports.multiTargetManager = multiTargetManager;\n// ページ読み込み状態管理\nconst pageLoadingState = {\n    isLoading: false,\n    startTime: null,\n    timeout: 10000\n};\nexports.pageLoadingState = pageLoadingState;\n// リロードカウントダウン状態管理\nconst reloadCountdownState = {\n    isActive: false,\n    timeLeft: 0,\n    intervalId: null,\n    onComplete: null,\n    totalSeconds: 30,\n    secondsRemaining: null,\n    startTime: null,\n    countdownInterval: null,\n    reloadTimer: null\n};\nexports.reloadCountdownState = reloadCountdownState;\n// カレンダー監視状態管理\nconst calendarWatchState = {\n    isWatching: false,\n    observer: null,\n    currentSelectedDate: null\n};\nexports.calendarWatchState = calendarWatchState;\n\n\n//# sourceURL=webpack://expo2025-extension/./src-modules/section2.ts?\n}");

/***/ }),

/***/ "./src-modules/section4.ts":
/*!*********************************!*\
  !*** ./src-modules/section4.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.timeSlotSelectors = void 0;\nexports.generateUniqueTdSelector = generateUniqueTdSelector;\nexports.getTdPositionInfo = getTdPositionInfo;\nexports.findSameTdElement = findSameTdElement;\nexports.extractTdStatus = extractTdStatus;\nexports.initTimeSlotMonitoring = initTimeSlotMonitoring;\nexports.waitForCalendar = waitForCalendar;\n// Section 5からのimport\nconst section5_1 = __webpack_require__(/*! ./section5 */ \"./src-modules/section5.ts\");\n// 【4. DOM要素セレクタ・検索】\n// ============================================================================\n// 時間帯セレクタ定義（設計書の固定DOM構造に基づく）\nconst timeSlotSelectors = {\n    // 時間帯選択エリア\n    timeSlotContainer: \"table\",\n    timeSlotCells: \"td[data-gray-out] div[role='button']\",\n    // 状態判定 - 設計書の構造に基づく正確な定義\n    availableSlots: \"td[data-gray-out] div[role='button']:not([data-disabled='true'])\",\n    fullSlots: \"td[data-gray-out] div[role='button'][data-disabled='true']\",\n    selectedSlot: \"td[data-gray-out] div[role='button'][aria-pressed='true']\",\n    // アイコン判定 - img要素は div[role='button'] 内の dd 要素内に存在\n    lowIcon: \"img[src*='ico_scale_low.svg']\",\n    highIcon: \"img[src*='ico_scale_high.svg']\",\n    fullIcon: \"img[src*='calendar_ng.svg']\"\n};\nexports.timeSlotSelectors = timeSlotSelectors;\n// td要素の一意特定機能\nfunction generateUniqueTdSelector(tdElement) {\n    // td要素の親要素（tr）内での位置を取得\n    const row = tdElement.parentElement;\n    const rowIndex = Array.from(row.parentElement.children).indexOf(row);\n    const cellIndex = Array.from(row.children).indexOf(tdElement);\n    // 設計書に基づく固定DOM構造での一意セレクタ\n    return `table tr:nth-child(${rowIndex + 1}) td:nth-child(${cellIndex + 1})[data-gray-out]`;\n}\nfunction getTdPositionInfo(tdElement) {\n    const row = tdElement.parentElement;\n    const rowIndex = Array.from(row.parentElement.children).indexOf(row);\n    const cellIndex = Array.from(row.children).indexOf(tdElement);\n    return { rowIndex, cellIndex };\n}\nfunction findSameTdElement(targetInfo) {\n    // 1. セレクタベースでの検索を優先\n    if (targetInfo.tdSelector) {\n        const element = document.querySelector(targetInfo.tdSelector);\n        if (element) {\n            return element;\n        }\n    }\n    // 2. フォールバック: 位置情報による検索\n    if (targetInfo.positionInfo &&\n        targetInfo.positionInfo.rowIndex !== undefined &&\n        targetInfo.positionInfo.cellIndex !== undefined) {\n        const table = document.querySelector(timeSlotSelectors.timeSlotContainer);\n        if (table) {\n            const rows = table.querySelectorAll('tr');\n            if (rows[targetInfo.positionInfo.rowIndex]) {\n                const cells = rows[targetInfo.positionInfo.rowIndex].querySelectorAll('td[data-gray-out]');\n                if (cells[targetInfo.positionInfo.cellIndex]) {\n                    return cells[targetInfo.positionInfo.cellIndex];\n                }\n            }\n        }\n    }\n    return null;\n}\nfunction extractTdStatus(tdElement) {\n    if (!tdElement)\n        return null;\n    const buttonDiv = tdElement.querySelector('div[role=\"button\"]');\n    if (!buttonDiv)\n        return null;\n    const timeSpan = buttonDiv.querySelector('dt span');\n    const timeText = timeSpan ? timeSpan.textContent?.trim() || '' : '';\n    // 満員判定\n    const isDisabled = buttonDiv.hasAttribute('data-disabled') && buttonDiv.getAttribute('data-disabled') === 'true';\n    const hasFullIcon = buttonDiv.querySelector('img[src*=\"calendar_ng.svg\"]');\n    const isFull = isDisabled && !!hasFullIcon;\n    // 利用可能判定\n    const hasLowIcon = buttonDiv.querySelector('img[src*=\"ico_scale_low.svg\"]');\n    const hasHighIcon = buttonDiv.querySelector('img[src*=\"ico_scale_high.svg\"]');\n    const isAvailable = !isDisabled && !!(hasLowIcon || hasHighIcon);\n    // 選択状態判定\n    const isSelected = buttonDiv.classList.contains('selected') ||\n        buttonDiv.hasAttribute('aria-selected') ||\n        buttonDiv.getAttribute('aria-pressed') === 'true';\n    // ステータス判定\n    let status;\n    if (isSelected) {\n        status = 'selected';\n    }\n    else if (isFull) {\n        status = 'full';\n    }\n    else if (isAvailable) {\n        status = 'available';\n    }\n    else {\n        status = 'unknown';\n    }\n    return {\n        timeText,\n        isFull,\n        isAvailable,\n        isSelected,\n        status,\n        element: buttonDiv,\n        tdElement\n    };\n}\n// 時間帯監視機能の初期化\nasync function initTimeSlotMonitoring() {\n    console.log('時間帯監視機能を初期化中...');\n    // カレンダーの存在確認\n    const hasCalendar = await waitForCalendar();\n    if (!hasCalendar) {\n        console.log('カレンダーが見つかりません');\n        return;\n    }\n    // DOM変化監視を開始（時間帯テーブルの動的生成を検出）\n    (0, section5_1.startTimeSlotTableObserver)();\n    console.log('時間帯監視機能の初期化完了（カレンダー監視中）');\n}\n// カレンダーの動的待機\nasync function waitForCalendar(timeout = 10000) {\n    const startTime = Date.now();\n    const checkInterval = 500;\n    console.log('カレンダーの出現を待機中...');\n    while (Date.now() - startTime < timeout) {\n        // :has()のフォールバック - カレンダーテーブルを検索\n        let calendar = document.querySelector('table:has(time[datetime])');\n        if (!calendar) {\n            // :has()がサポートされていない場合のフォールバック\n            calendar = document.querySelector('[class*=\"calendar_table\"]');\n            if (!calendar) {\n                const tables = document.querySelectorAll('table');\n                for (const table of tables) {\n                    if (table.querySelectorAll('time[datetime]').length > 0) {\n                        calendar = table;\n                        break;\n                    }\n                }\n            }\n        }\n        if (calendar) {\n            // カレンダー要素内の日付要素も確認\n            const dateElements = calendar.querySelectorAll('time[datetime]');\n            if (dateElements.length > 0) {\n                console.log(`カレンダーを検出しました（日付要素: ${dateElements.length}個）`);\n                return true;\n            }\n            else {\n                console.log('カレンダー要素はあるが、日付要素がまだ読み込まれていません');\n            }\n        }\n        await new Promise(resolve => setTimeout(resolve, checkInterval));\n    }\n    console.log('カレンダーの待機がタイムアウトしました');\n    return false;\n}\n// ============================================================================\n\n\n//# sourceURL=webpack://expo2025-extension/./src-modules/section4.ts?\n}");

/***/ }),

/***/ "./src-modules/section5.ts":
/*!*********************************!*\
  !*** ./src-modules/section5.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setCacheManager = exports.setExternalFunctions = void 0;\nexports.startTimeSlotTableObserver = startTimeSlotTableObserver;\nexports.waitForTimeSlotTable = waitForTimeSlotTable;\nexports.checkTimeSlotTableExistsSync = checkTimeSlotTableExistsSync;\nexports.analyzeAndAddMonitorButtons = analyzeAndAddMonitorButtons;\nexports.analyzeTimeSlots = analyzeTimeSlots;\nexports.extractTimeSlotInfo = extractTimeSlotInfo;\nexports.generateSelectorForElement = generateSelectorForElement;\nexports.addMonitorButtonsToFullSlots = addMonitorButtonsToFullSlots;\nexports.getMonitorButtonText = getMonitorButtonText;\nexports.updateAllMonitorButtonPriorities = updateAllMonitorButtonPriorities;\nexports.createMonitorButton = createMonitorButton;\nexports.handleMonitorButtonClick = handleMonitorButtonClick;\nexports.startSlotMonitoring = startSlotMonitoring;\nexports.checkSlotAvailabilityAndReload = checkSlotAvailabilityAndReload;\nexports.findTargetSlotInPage = findTargetSlotInPage;\nexports.terminateMonitoring = terminateMonitoring;\nexports.checkTargetElementExists = checkTargetElementExists;\nexports.checkTimeSlotTableExistsAsync = checkTimeSlotTableExistsAsync;\nexports.validatePageLoaded = validatePageLoaded;\nexports.checkMaxReloads = checkMaxReloads;\n// Section 2からのimport\nconst section2_1 = __webpack_require__(/*! ./section2 */ \"./src-modules/section2.ts\");\n// Section 4からのimport\nconst section4_1 = __webpack_require__(/*! ./section4 */ \"./src-modules/section4.ts\");\n// 【5. 時間帯監視・分析システム】\n// ============================================================================\n// 依存注入用の外部関数参照\nlet externalFunctions = {};\nlet isInitialized = false;\n// 必要な外部関数のリスト\nconst REQUIRED_FUNCTIONS = [\n    'getCurrentTableContent',\n    'shouldUpdateMonitorButtons',\n    'restoreSelectionAfterUpdate',\n    // 'showStatus', // 内部関数のため一時的に除外\n    'enableAllMonitorButtons',\n    'updateMainButtonDisplay',\n    'updateMonitoringTargetsDisplay',\n    'disableAllMonitorButtons',\n    'selectTimeSlotAndStartReservation',\n    'startReloadCountdown',\n    'reloadCountdownState',\n    'resetMonitoringUI',\n    'showErrorMessage',\n    'tryClickCalendarForTimeSlot'\n];\n// 外部関数を設定するヘルパー関数\nconst setExternalFunctions = (funcs) => {\n    // 必要な関数がすべて存在するかチェック\n    for (const funcName of REQUIRED_FUNCTIONS) {\n        if (typeof funcs[funcName] !== 'function' && typeof funcs[funcName] !== 'object') {\n            console.warn(`Warning: Required function/object ${funcName} not provided or not a function`);\n        }\n    }\n    externalFunctions = funcs;\n    isInitialized = true;\n    console.log('✅ Section 5: External functions initialized');\n};\nexports.setExternalFunctions = setExternalFunctions;\n// 安全な外部関数呼び出し\nconst safeCall = (funcName, ...args) => {\n    if (!isInitialized) {\n        throw new Error('External functions not initialized in Section 5');\n    }\n    if (typeof externalFunctions[funcName] !== 'function') {\n        throw new Error(`Function ${funcName} not available in Section 5`);\n    }\n    return externalFunctions[funcName](...args);\n};\n// 安全な外部オブジェクト参照\nfunction safeRef(objName) {\n    if (!isInitialized) {\n        throw new Error('External functions not initialized in Section 5');\n    }\n    if (!externalFunctions[objName]) {\n        throw new Error(`Object ${objName} not available in Section 5`);\n    }\n    return externalFunctions[objName];\n}\n// 依存注入用のcacheManager参照\nlet cacheManager = null;\n// cacheManagerを設定するヘルパー関数\nconst setCacheManager = (cm) => {\n    cacheManager = cm;\n};\nexports.setCacheManager = setCacheManager;\n// 時間帯テーブルの動的生成を監視（ループ防止版）\nfunction startTimeSlotTableObserver() {\n    console.log('時間帯テーブルの動的生成監視を開始');\n    let isProcessing = false; // 処理中フラグでループ防止\n    let lastTableContent = ''; // 前回のテーブル内容を記録\n    // MutationObserverで DOM変化を監視（フィルタリング強化版）\n    const observer = new MutationObserver((mutations) => {\n        if (isProcessing) {\n            console.log('⏭️ 処理中のため変更を無視');\n            return;\n        }\n        let hasRelevantChange = false;\n        mutations.forEach((mutation) => {\n            // console.log(`📊 DOM変更検出: type=${mutation.type}, target=${mutation.target.tagName}`, mutation);\n            if (mutation.type === 'childList') {\n                const addedNodes = Array.from(mutation.addedNodes);\n                const removedNodes = Array.from(mutation.removedNodes);\n                // 監視ボタン関連の変更は無視\n                const isMonitorButtonChange = [...addedNodes, ...removedNodes].some(node => {\n                    if (node.nodeType === Node.ELEMENT_NODE) {\n                        const element = node;\n                        return element.classList?.contains('monitor-btn') ||\n                            element.querySelector?.('.monitor-btn');\n                    }\n                    return false;\n                });\n                if (isMonitorButtonChange) {\n                    console.log('🚫 監視ボタン関連の変更を無視');\n                    return;\n                }\n                // 時間帯テーブル関連の変更のみ検出\n                const hasTableChange = [...addedNodes, ...removedNodes].some(node => {\n                    if (node.nodeType === Node.ELEMENT_NODE) {\n                        const element = node;\n                        const isRelevant = element.tagName === 'TABLE' ||\n                            element.tagName === 'TD' ||\n                            element.tagName === 'IMG' || // アイコン変更も検出\n                            (element.querySelector && (element.querySelector('table') ||\n                                element.querySelector('td[data-gray-out]') ||\n                                element.querySelector('div[role=\"button\"]:not(.monitor-btn)') ||\n                                element.querySelector('img[src*=\"calendar_ng.svg\"]') ||\n                                element.querySelector('img[src*=\"ico_scale\"]')));\n                        if (isRelevant) {\n                            // console.log(`🔍 テーブル関連の変更を検出: ${element.tagName}`, element);\n                        }\n                        return isRelevant;\n                    }\n                    return false;\n                });\n                if (hasTableChange) {\n                    hasRelevantChange = true;\n                }\n            }\n            else if (mutation.type === 'attributes') {\n                // 属性変更も監視（data-disabled、src等）\n                const target = mutation.target;\n                const attrName = mutation.attributeName;\n                if (target.nodeType === Node.ELEMENT_NODE) {\n                    const isRelevantAttr = ((attrName === 'data-disabled' && target.tagName === 'DIV' && target.getAttribute('role') === 'button') ||\n                        (attrName === 'src' && target.tagName === 'IMG') ||\n                        (attrName === 'aria-pressed' && target.tagName === 'DIV' && target.getAttribute('role') === 'button'));\n                    if (isRelevantAttr) {\n                        // console.log(`🔄 属性変更を検出: ${attrName}=${target.getAttribute(attrName)}`, target);\n                        hasRelevantChange = true;\n                    }\n                }\n            }\n        });\n        if (hasRelevantChange) {\n            // デバウンス処理\n            clearTimeout(window.timeSlotCheckTimeout);\n            window.timeSlotCheckTimeout = window.setTimeout(() => {\n                // 現在のテーブル内容をチェック\n                const currentTableContent = safeCall('getCurrentTableContent');\n                if (currentTableContent === lastTableContent) {\n                    console.log('📋 テーブル内容に変化なし、処理をスキップ');\n                    return;\n                }\n                // console.log('🔍 有効な時間帯テーブル変更を検出');\n                isProcessing = true;\n                const hasTimeSlot = checkTimeSlotTableExistsSync();\n                if (hasTimeSlot) {\n                    // 現在の監視ボタンの状態をチェック\n                    if (safeCall('shouldUpdateMonitorButtons')) {\n                        console.log('🎯 監視ボタンの更新が必要です');\n                        setTimeout(() => {\n                            // 差分更新処理（不要なボタン削除と新規ボタン追加）\n                            analyzeAndAddMonitorButtons();\n                            // 選択状態を復元\n                            setTimeout(() => {\n                                safeCall('restoreSelectionAfterUpdate');\n                                // テーブル内容を記録\n                                lastTableContent = safeCall('getCurrentTableContent');\n                                isProcessing = false;\n                            }, 200);\n                        }, 300);\n                    }\n                    else {\n                        console.log('✅ 監視ボタンは既に適切に配置されています');\n                        lastTableContent = safeCall('getCurrentTableContent');\n                        isProcessing = false;\n                    }\n                }\n                else {\n                    isProcessing = false;\n                }\n            }, 800);\n        }\n    });\n    // 監視範囲を限定（属性変更も監視）\n    observer.observe(document.body, {\n        childList: true,\n        subtree: true,\n        attributes: true,\n        attributeFilter: ['data-disabled', 'src', 'aria-pressed']\n    });\n    // 初回チェック\n    setTimeout(() => {\n        if (checkTimeSlotTableExistsSync()) {\n            console.log('既存の時間帯テーブルを検出');\n            isProcessing = true;\n            analyzeAndAddMonitorButtons(); // 差分更新で処理\n            lastTableContent = safeCall('getCurrentTableContent');\n            isProcessing = false;\n        }\n    }, 1000);\n    console.log('継続的な時間帯テーブル監視を開始しました（ループ防止版）');\n}\n// 時間帯テーブルの動的待機\nasync function waitForTimeSlotTable(timeout = 10000) {\n    const startTime = Date.now();\n    const checkInterval = 500;\n    console.log('時間帯テーブルの出現を待機中...');\n    while (Date.now() - startTime < timeout) {\n        if (checkTimeSlotTableExistsSync()) {\n            console.log('時間帯テーブルを検出しました');\n            return true;\n        }\n        // ランダム待機時間で次のチェック\n        const waitTime = checkInterval + Math.floor(Math.random() * 200);\n        await new Promise(resolve => setTimeout(resolve, waitTime));\n    }\n    console.log(`時間帯テーブルの待機がタイムアウトしました (${timeout}ms)`);\n    return false;\n}\n// 時間帯テーブルの存在確認（同期版）\nfunction checkTimeSlotTableExistsSync() {\n    // 実際の時間帯要素をチェック（時間を含むもの）\n    const allElements = document.querySelectorAll(section4_1.timeSlotSelectors.timeSlotCells);\n    const actualTimeSlots = [];\n    allElements.forEach(el => {\n        const text = el.textContent?.trim();\n        // 時間帯の形式をチェック（例: \"9:00-\", \"11:00-\", \"13時\"など）\n        if (text && (text.includes(':') && text.includes('-') || text.includes('時'))) {\n            actualTimeSlots.push(el);\n        }\n    });\n    if (actualTimeSlots.length > 0) {\n        // ログを削除\n        // console.log(`✅ 実際の時間帯要素を${actualTimeSlots.length}個検出`);\n        return true;\n    }\n    // console.log('❌ 実際の時間帯要素が見つかりません（カレンダー日付のみ）');\n    return false;\n}\n// 時間帯分析とボタン追加のメイン処理\nfunction analyzeAndAddMonitorButtons() {\n    const analysis = analyzeTimeSlots();\n    console.log('時間帯分析結果:', {\n        available: analysis.available.length,\n        full: analysis.full.length,\n        selected: analysis.selected.length\n    });\n    // 既存のボタンとの差分を計算（時間+位置で判定）\n    const existingButtons = document.querySelectorAll('.monitor-btn');\n    const existingSlots = Array.from(existingButtons).map(btn => {\n        const timeText = btn.getAttribute('data-target-time') || '';\n        const tdElement = btn.closest('td[data-gray-out]');\n        const tdSelector = tdElement ? (0, section4_1.generateUniqueTdSelector)(tdElement) : '';\n        return { timeText, tdSelector };\n    });\n    console.log(`📋 差分計算: 既存ボタン数=${existingButtons.length}個 vs 満員時間帯数=${analysis.full.length}個`);\n    // 不要なボタンを削除（時間+位置で判定）\n    let removedCount = 0;\n    existingButtons.forEach(button => {\n        const timeText = button.getAttribute('data-target-time') || '';\n        const tdElement = button.closest('td[data-gray-out]');\n        const tdSelector = tdElement ? (0, section4_1.generateUniqueTdSelector)(tdElement) : '';\n        // 監視対象として設定済みの場合は削除しない（状態変化を追跡するため）\n        const isMonitoringTarget = section2_1.multiTargetManager.isSelected(timeText, tdSelector);\n        if (isMonitoringTarget) {\n            console.log(`🎯 監視対象のため保持: ${timeText} (状態変化を追跡中)`);\n            // 監視対象の状態が変わった場合はボタンテキストを更新\n            const currentTd = button.closest('td[data-gray-out]');\n            const currentStatus = (0, section4_1.extractTdStatus)(currentTd);\n            if (currentStatus && currentStatus.isAvailable) {\n                const span = button.querySelector('span');\n                if (span) {\n                    span.innerText = '空きあり';\n                    button.style.background = 'rgb(0, 200, 0)'; // より明るい緑\n                    console.log(`✅ 監視対象が空きありに変化: ${timeText}`);\n                }\n            }\n        }\n        else {\n            // 現在の満員時間帯に対応するものがあるかチェック\n            const stillExists = analysis.full.some(slot => {\n                const slotTdElement = slot.element.closest('td[data-gray-out]');\n                const slotTdSelector = (0, section4_1.generateUniqueTdSelector)(slotTdElement);\n                return slot.timeText === timeText && slotTdSelector === tdSelector;\n            });\n            if (!stillExists) {\n                console.log(`🗑️ 不要な監視ボタンを削除: ${timeText} (位置も不一致)`);\n                button.remove();\n                removedCount++;\n            }\n        }\n    });\n    // 新しい満員時間帯にボタンを追加（時間+位置で判定）\n    const newFullSlots = analysis.full.filter(slot => {\n        const slotTdElement = slot.element.closest('td[data-gray-out]');\n        const slotTdSelector = (0, section4_1.generateUniqueTdSelector)(slotTdElement);\n        return !existingSlots.some(existing => existing.timeText === slot.timeText && existing.tdSelector === slotTdSelector);\n    });\n    if (newFullSlots.length > 0) {\n        console.log(`${newFullSlots.length}個の新しい満員時間帯に監視ボタンを追加します`);\n        addMonitorButtonsToFullSlots(newFullSlots);\n    }\n    // 結果サマリー\n    if (analysis.full.length === 0) {\n        console.log('現在満員の時間帯はありません');\n        if (existingButtons.length > 0) {\n            console.log(`${existingButtons.length}個の既存ボタンを削除しました`);\n        }\n    }\n    else if (newFullSlots.length === 0 && removedCount === 0) {\n        console.log('監視ボタンは既に適切に配置されています');\n    }\n    else {\n        console.log(`✅ 監視ボタン更新完了: 削除=${removedCount}個, 追加=${newFullSlots.length}個`);\n    }\n}\n// 全時間帯の状態分析\nfunction analyzeTimeSlots() {\n    const available = [];\n    const full = [];\n    const selected = [];\n    // 全てのtd要素を取得（時間帯テーブル内）\n    const allTdElements = document.querySelectorAll(section4_1.timeSlotSelectors.timeSlotContainer + ' td[data-gray-out]');\n    console.log(`📊 時間帯分析開始: ${allTdElements.length}個のtd要素を確認`);\n    allTdElements.forEach(tdElement => {\n        const status = (0, section4_1.extractTdStatus)(tdElement);\n        if (status && status.timeText) {\n            const isFull = status.isFull;\n            const isAvailable = status.isAvailable;\n            const isSelected = status.element.getAttribute('aria-pressed') === 'true';\n            let statusType = 'unknown';\n            if (isFull) {\n                statusType = 'full';\n            }\n            else if (isSelected) {\n                statusType = 'selected';\n            }\n            else if (isAvailable) {\n                statusType = 'available';\n            }\n            console.log(`📊 ${status.timeText}: ${statusType} (満員:${isFull}, 利用可能:${isAvailable}, 選択:${isSelected})`);\n            const timeInfo = {\n                element: status.element,\n                tdElement: status.tdElement,\n                timeText: status.timeText,\n                isAvailable: isAvailable,\n                isFull: isFull,\n                tdSelector: (0, section4_1.generateUniqueTdSelector)(status.tdElement)\n            };\n            if (statusType === 'full') {\n                full.push(timeInfo);\n            }\n            else if (statusType === 'selected') {\n                selected.push(timeInfo);\n            }\n            else if (statusType === 'available') {\n                available.push(timeInfo);\n            }\n        }\n    });\n    console.log(`📊 分析結果: 利用可能=${available.length}, 満員=${full.length}, 選択=${selected.length}`);\n    return { available, full, selected };\n}\n// 時間帯要素から情報を抽出\nfunction extractTimeSlotInfo(buttonElement) {\n    const tdElement = buttonElement.closest('td');\n    if (!tdElement)\n        return null;\n    // 時間テキストを取得\n    const timeSpan = buttonElement.querySelector('dt span');\n    const timeText = timeSpan ? timeSpan.textContent?.trim() || '' : '';\n    // デバッグ用：要素の状態を詳細表示\n    const dataDisabled = buttonElement.getAttribute('data-disabled');\n    const ariaPressed = buttonElement.getAttribute('aria-pressed');\n    const hasActiveClass = Array.from(buttonElement.classList).some(className => className.includes('style_active__'));\n    // アイコンによる満員判定（calendar_ng.svgが最も確実）\n    const fullIcon = buttonElement.querySelector('img[src*=\"calendar_ng.svg\"]');\n    const lowIcon = buttonElement.querySelector('img[src*=\"ico_scale_low.svg\"]');\n    const highIcon = buttonElement.querySelector('img[src*=\"ico_scale_high.svg\"]');\n    let iconType = 'unknown';\n    let isAvailable = false;\n    let isFull = false;\n    // アイコンベースでの判定\n    if (fullIcon) {\n        iconType = 'full';\n        isFull = true;\n    }\n    else if (highIcon) {\n        iconType = 'high';\n        isAvailable = true;\n    }\n    else if (lowIcon) {\n        iconType = 'low';\n        isAvailable = true;\n    }\n    // data-disabled属性での追加確認\n    if (dataDisabled === 'true') {\n        isFull = true;\n        isAvailable = false;\n    }\n    // デバッグ情報\n    console.log(`時間帯解析: ${timeText} - isFull: ${isFull}, isAvailable: ${isAvailable}, iconType: ${iconType}, disabled: ${dataDisabled}, pressed: ${ariaPressed}, hasFullIcon: ${!!fullIcon}`);\n    return {\n        element: buttonElement,\n        tdElement: tdElement,\n        timeText: timeText,\n        isAvailable: isAvailable,\n        isFull: isFull,\n        tdSelector: generateSelectorForElement(buttonElement)\n    };\n}\n// 要素のセレクタを生成（フォールバック用）\nfunction generateSelectorForElement(element) {\n    const timeSpan = element.querySelector('dt span');\n    const timeText = timeSpan ? timeSpan.textContent?.trim() || '' : '';\n    return `td[data-gray-out] div[role='button'] dt span:contains('${timeText}')`;\n}\n// 満員時間帯にモニタリングボタンを追加\nfunction addMonitorButtonsToFullSlots(fullSlots) {\n    fullSlots.forEach(slotInfo => {\n        createMonitorButton(slotInfo);\n    });\n}\n// 監視ボタンのテキストを決定（優先順位表示）\nfunction getMonitorButtonText(slotInfo) {\n    const tdElement = slotInfo.element.closest('td[data-gray-out]');\n    const tdSelector = (0, section4_1.generateUniqueTdSelector)(tdElement);\n    // 既に監視対象として選択されているかチェック\n    const isSelected = section2_1.multiTargetManager.isSelected(slotInfo.timeText, tdSelector);\n    if (isSelected) {\n        // 監視対象リストでの位置を取得（1ベース）\n        const targets = section2_1.multiTargetManager.getTargets();\n        const targetIndex = targets.findIndex(target => target.timeText === slotInfo.timeText && target.tdSelector === tdSelector);\n        if (targetIndex >= 0) {\n            const priority = targetIndex + 1; // 1ベースの優先順位\n            return `監視${priority}`;\n        }\n    }\n    return '満員';\n}\n// すべての監視ボタンの優先順位を更新\nfunction updateAllMonitorButtonPriorities() {\n    const allMonitorButtons = document.querySelectorAll('.monitor-btn');\n    const targets = section2_1.multiTargetManager.getTargets();\n    allMonitorButtons.forEach(button => {\n        const span = button.querySelector('span');\n        const timeText = button.getAttribute('data-target-time') || '';\n        if (span && timeText) {\n            // このボタンの時間帯と位置情報を特定\n            const tdElement = button.closest('td[data-gray-out]');\n            if (tdElement) {\n                const tdSelector = (0, section4_1.generateUniqueTdSelector)(tdElement);\n                // 監視対象リストでの位置を検索\n                const targetIndex = targets.findIndex(target => target.timeText === timeText && target.tdSelector === tdSelector);\n                if (targetIndex >= 0) {\n                    // 監視対象として選択されている場合、優先順位を表示\n                    const priority = targetIndex + 1;\n                    span.innerText = `監視${priority}`;\n                    button.style.background = 'rgb(0, 104, 33)';\n                }\n                else {\n                    // 監視対象でない場合は「満員」\n                    span.innerText = '満員';\n                    button.style.background = 'rgb(255, 140, 0)';\n                }\n            }\n        }\n    });\n    console.log(`✅ すべての監視ボタンの優先順位を更新しました (${targets.length}個の監視対象)`);\n}\n// 個別監視ボタンの作成（満員要素のみ）\nfunction createMonitorButton(slotInfo) {\n    const { element, timeText } = slotInfo;\n    // 満員要素以外にはボタンを追加しない\n    if (!slotInfo.isFull) {\n        console.log(`満員ではないためボタンを追加しません: ${timeText} (isFull: ${slotInfo.isFull})`);\n        return;\n    }\n    // dt要素を探す\n    const dtElement = element.querySelector('dt');\n    if (!dtElement) {\n        console.log(`dt要素が見つかりません: ${timeText}`);\n        return;\n    }\n    // 既にボタンが存在するかチェック\n    const existingButton = dtElement.querySelector('.monitor-btn');\n    if (existingButton) {\n        console.log(`監視ボタンは既に存在します: ${timeText}`);\n        return;\n    }\n    // 監視ボタンを作成（満員要素のクリック制限を回避）\n    const monitorButton = document.createElement('button');\n    monitorButton.classList.add('ext-ytomo', 'monitor-btn');\n    monitorButton.setAttribute('data-target-time', timeText);\n    monitorButton.style.cssText = `\n        height: auto;\n        min-height: 20px;\n        width: auto;\n        min-width: 35px;\n        padding: 1px 4px;\n        background: rgb(255, 140, 0) !important;\n        color: white !important;\n        margin-left: 8px;\n        font-size: 10px;\n        border: none !important;\n        border-radius: 2px;\n        cursor: pointer !important;\n        display: inline-block;\n        vertical-align: middle;\n        position: relative;\n        z-index: 9999 !important;\n        pointer-events: auto !important;\n        opacity: 1 !important;\n        visibility: visible !important;\n    `;\n    // ボタンテキストとイベントリスナー\n    const buttonSpan = document.createElement('span');\n    buttonSpan.classList.add('ext-ytomo');\n    // 優先順位形式でボタンテキストを設定\n    const buttonText = getMonitorButtonText(slotInfo);\n    buttonSpan.innerText = buttonText;\n    monitorButton.appendChild(buttonSpan);\n    // クリックイベント（確実な処理のため）\n    monitorButton.addEventListener('click', (event) => {\n        event.preventDefault();\n        event.stopPropagation();\n        event.stopImmediatePropagation();\n        const tdElement = slotInfo.element.closest('td[data-gray-out]');\n        const tdSelector = (0, section4_1.generateUniqueTdSelector)(tdElement);\n        const location = section2_1.multiTargetManager.getLocationFromSelector(tdSelector);\n        console.log(`🖱️ 監視ボタンクリック検出: ${location}${slotInfo.timeText}`);\n        // ボタン要素の確認\n        const span = monitorButton.querySelector('span');\n        console.log(`現在のボタンテキスト: \"${span?.innerText}\"`);\n        console.log(`ボタンdisabled状態: ${monitorButton.disabled}`);\n        handleMonitorButtonClick(slotInfo, monitorButton);\n    }, true); // useCapture = true で確実にキャッチ\n    // マウスイベントも制御\n    monitorButton.addEventListener('mousedown', (event) => {\n        event.preventDefault();\n        event.stopPropagation();\n        event.stopImmediatePropagation();\n    });\n    // ダブルクリック防止\n    monitorButton.addEventListener('dblclick', (event) => {\n        event.preventDefault();\n        event.stopPropagation();\n    });\n    monitorButton.addEventListener('mouseup', (event) => {\n        event.preventDefault();\n        event.stopPropagation();\n        event.stopImmediatePropagation();\n    });\n    // dt要素内に追加（spanの後）\n    dtElement.appendChild(monitorButton);\n    console.log(`満員時間帯に監視ボタンを追加しました: ${timeText}`);\n}\n// 監視ボタンクリック処理（選択・解除切り替え）\nfunction handleMonitorButtonClick(slotInfo, buttonElement) {\n    const tdElement = slotInfo.element.closest('td[data-gray-out]');\n    const tdSelector = (0, section4_1.generateUniqueTdSelector)(tdElement);\n    const location = section2_1.multiTargetManager.getLocationFromSelector(tdSelector);\n    console.log(`監視ボタンがクリックされました: ${location}${slotInfo.timeText}`);\n    // 監視実行中は操作不可\n    if (section2_1.timeSlotState.isMonitoring) {\n        console.log('⚠️ 監視実行中のため操作できません');\n        return;\n    }\n    const buttonSpan = buttonElement.querySelector('span');\n    const currentText = buttonSpan.innerText;\n    const isCurrentlySelected = currentText.startsWith('監視'); // '監視1', '監視2' etc.\n    console.log(`現在の状態: ${isCurrentlySelected ? '選択中' : '未選択'} (テキスト: \"${currentText}\")`);\n    if (isCurrentlySelected) {\n        // 現在選択中の場合は解除\n        console.log(`監視対象を解除します: ${location}${slotInfo.timeText}`);\n        // 複数対象管理から削除（時間+位置で特定）\n        section2_1.multiTargetManager.removeTarget(slotInfo.timeText, tdSelector);\n        // ボタンの表示を元に戻す\n        buttonSpan.innerText = '満員';\n        buttonElement.style.background = 'rgb(255, 140, 0)';\n        buttonElement.style.opacity = '1';\n        buttonElement.style.cursor = 'pointer';\n        buttonElement.disabled = false;\n        // 監視対象がすべてなくなった場合の処理\n        if (!section2_1.multiTargetManager.hasTargets()) {\n            section2_1.timeSlotState.mode = 'idle';\n            section2_1.timeSlotState.retryCount = 0;\n            // キャッシュをクリア\n            if (cacheManager) {\n                cacheManager.clearTargetSlots();\n                cacheManager.clearMonitoringFlag(); // 監視継続フラグもクリア\n            }\n            // 他のボタンを有効化\n            safeCall('enableAllMonitorButtons');\n        }\n        else {\n            // キャッシュを更新（残りの監視対象で）\n            if (cacheManager) {\n                cacheManager.saveTargetSlots();\n            }\n            // 残りのボタンの優先順位を更新\n            updateAllMonitorButtonPriorities();\n        }\n        // メインボタンの表示を更新\n        safeCall('updateMainButtonDisplay');\n        // 監視対象表示も更新\n        safeCall('updateMonitoringTargetsDisplay');\n        console.log(`✅ 監視対象を解除しました: ${location}${slotInfo.timeText}`);\n    }\n    else {\n        // 現在未選択の場合は選択\n        console.log(`監視対象を追加します: ${location}${slotInfo.timeText}`);\n        // 選択状態を設定（td要素の一意特定情報を追加）\n        const targetSlotInfo = {\n            ...slotInfo,\n            // td要素の一意特定情報を追加\n            tdSelector: (0, section4_1.generateUniqueTdSelector)(tdElement),\n            positionInfo: (0, section4_1.getTdPositionInfo)(tdElement)\n        };\n        // 複数対象管理に追加\n        const added = section2_1.multiTargetManager.addTarget(targetSlotInfo);\n        if (!added) {\n            console.log('⚠️ 既に選択済みの時間帯です');\n            return;\n        }\n        section2_1.timeSlotState.mode = 'selecting';\n        section2_1.timeSlotState.retryCount = 0;\n        // キャッシュに保存（すべての監視対象を保存）\n        if (cacheManager) {\n            cacheManager.saveTargetSlots();\n        }\n        // ボタンの表示を変更（優先順位表示）\n        const priority = section2_1.multiTargetManager.getCount(); // 追加後の順位\n        buttonSpan.innerText = `監視${priority}`;\n        buttonElement.style.background = 'rgb(0, 104, 33)';\n        buttonElement.style.opacity = '1';\n        buttonElement.style.cursor = 'pointer';\n        buttonElement.disabled = false; // クリックで解除できるように\n        // メインボタンの表示を更新\n        console.log(`🔄 監視対象設定後のFAB更新を実行: targetSlots=${section2_1.multiTargetManager.getCount()}個, mode=${section2_1.timeSlotState.mode}`);\n        safeCall('updateMainButtonDisplay');\n        // 監視対象表示も更新\n        safeCall('updateMonitoringTargetsDisplay');\n        // 更新後の状態も確認\n        setTimeout(() => {\n            const fabButton = document.querySelector('#ytomo-main-fab');\n            console.log(`🔍 FAB更新後の状態: disabled=${fabButton?.disabled}, hasDisabledAttr=${fabButton?.hasAttribute('disabled')}, text=\"${fabButton?.textContent?.trim()}\"`);\n        }, 100);\n        console.log(`✅ 時間帯 ${location}${slotInfo.timeText} を監視対象に設定しました`);\n    }\n}\n// 満員時間帯の可用性監視を開始\nasync function startSlotMonitoring() {\n    if (!section2_1.multiTargetManager.hasTargets()) {\n        console.log('❌ 監視対象時間帯が設定されていません');\n        return;\n    }\n    // 即座に状態更新（UI応答性向上）\n    section2_1.timeSlotState.mode = 'monitoring';\n    section2_1.timeSlotState.isMonitoring = true;\n    safeCall('updateMainButtonDisplay'); // 即座にボタン表示を更新\n    // 監視実行中は全ての監視ボタンを無効化\n    safeCall('disableAllMonitorButtons');\n    const targetCount = section2_1.multiTargetManager.getCount();\n    const targetTexts = section2_1.multiTargetManager.getTargets().map(t => {\n        const location = section2_1.multiTargetManager.getLocationFromSelector(t.tdSelector);\n        return `${location}${t.timeText}`;\n    }).join(', ');\n    console.log(`🔄 時間帯監視を開始: ${targetTexts} (${targetCount}個)`);\n    // 定期的な可用性チェック\n    section2_1.timeSlotState.monitoringInterval = window.setInterval(async () => {\n        await checkSlotAvailabilityAndReload();\n    }, section2_1.timeSlotState.reloadInterval + Math.random() * 5000); // ランダム性追加\n    // 即座に一回チェック（短縮）\n    setTimeout(() => {\n        checkSlotAvailabilityAndReload();\n    }, 500);\n}\n// 時間帯の可用性チェックとページ再読み込み\nasync function checkSlotAvailabilityAndReload() {\n    if (!section2_1.timeSlotState.isMonitoring || !section2_1.multiTargetManager.hasTargets()) {\n        return;\n    }\n    // バリデーションチェック\n    if (!validatePageLoaded())\n        return;\n    if (!(await checkTimeSlotTableExistsAsync()))\n        return;\n    // 複数監視対象の存在チェック\n    const targets = section2_1.multiTargetManager.getTargets();\n    for (const target of targets) {\n        if (!checkTargetElementExists(target))\n            return;\n    }\n    if (!checkMaxReloads(section2_1.timeSlotState.retryCount))\n        return;\n    section2_1.timeSlotState.retryCount++;\n    if (cacheManager) {\n        cacheManager.updateRetryCount(section2_1.timeSlotState.retryCount);\n    }\n    const targetTexts = targets.map(t => t.timeText).join(', ');\n    console.log(`🔍 可用性チェック (${section2_1.timeSlotState.retryCount}回目): ${targetTexts}`);\n    // 現在の時間帯をチェック\n    const currentSlot = findTargetSlotInPage();\n    console.log(`📊 監視チェック結果: currentSlot=${!!currentSlot}, status=${currentSlot?.status}`);\n    if (currentSlot && currentSlot.status === 'available') {\n        const location = section2_1.multiTargetManager.getLocationFromSelector(currentSlot.targetInfo.tdSelector);\n        console.log(`🎉🎉 対象時間帯が利用可能になりました！: ${location}${currentSlot.targetInfo.timeText}`);\n        console.log(`  → 監視を終了し、自動選択+予約を開始します`);\n        // ボタン表示を更新（見つかりましたモード）\n        safeCall('updateMainButtonDisplay', 'found-available');\n        // 自動選択\n        await safeCall('selectTimeSlotAndStartReservation', currentSlot);\n        return;\n    }\n    // まだ満員の場合はページリロード\n    console.log('⏳ すべての監視対象がまだ満員です。ページを再読み込みします...');\n    // リロード前に監視継続フラグを設定\n    const flagTimestamp = Date.now();\n    if (cacheManager) {\n        cacheManager.setMonitoringFlag(true);\n    }\n    console.log(`🏃 監視継続フラグ設定時刻: ${new Date(flagTimestamp).toLocaleTimeString()}`);\n    // BAN対策：設定されたリロード間隔にランダム要素を追加\n    const baseInterval = section2_1.timeSlotState.reloadInterval; // 30000ms (30秒)\n    const randomVariation = Math.random() * 5000; // 0-5秒のランダム要素\n    const totalWaitTime = baseInterval + randomVariation;\n    const displaySeconds = Math.ceil(totalWaitTime / 1000);\n    // カウントダウン開始（即座にUI更新）\n    safeCall('startReloadCountdown', displaySeconds);\n    // リロードタイマーを保存（中断時に停止するため）\n    section2_1.reloadCountdownState.reloadTimer = window.setTimeout(() => {\n        console.log('🔄 監視継続のためページをリロードします...');\n        window.location.reload();\n    }, totalWaitTime);\n}\n// ページ内で対象時間帯を検索（複数対象の状態変化をチェック）\nfunction findTargetSlotInPage() {\n    const targets = section2_1.multiTargetManager.getTargets();\n    if (targets.length === 0)\n        return null;\n    // 複数監視対象をチェック\n    for (const target of targets) {\n        // 監視開始時に保存した要素特定情報を使用して同一td要素を検索\n        const targetTd = (0, section4_1.findSameTdElement)(target);\n        if (targetTd) {\n            // 同一td要素の現在の状態を取得\n            const currentStatus = (0, section4_1.extractTdStatus)(targetTd);\n            const location = section2_1.multiTargetManager.getLocationFromSelector(target.tdSelector);\n            // 詳細なデバッグ情報を出力\n            const buttonElement = targetTd.querySelector('div[role=\"button\"]');\n            const dataDisabled = buttonElement?.getAttribute('data-disabled');\n            const fullIcon = buttonElement?.querySelector('img[src*=\"calendar_ng.svg\"]');\n            const lowIcon = buttonElement?.querySelector('img[src*=\"ico_scale_low.svg\"]');\n            const highIcon = buttonElement?.querySelector('img[src*=\"ico_scale_high.svg\"]');\n            console.log(`🔍 監視対象要素を発見: ${location}${target.timeText}`);\n            console.log(`  - 現在状態: isAvailable=${currentStatus?.isAvailable}, isFull=${currentStatus?.isFull}`);\n            console.log(`  - data-disabled: ${dataDisabled}`);\n            console.log(`  - 満員アイコン: ${!!fullIcon}, 低混雑: ${!!lowIcon}, 高空き: ${!!highIcon}`);\n            // 利用可能になったかチェック\n            if (currentStatus && currentStatus.isAvailable) {\n                console.log(`🎉 監視対象要素が利用可能になりました！: ${location}${target.timeText}`);\n                console.log(`  → 監視を終了して自動選択を開始します`);\n                return { ...currentStatus, targetInfo: target, status: 'available' };\n            }\n            else if (currentStatus && currentStatus.isFull) {\n                console.log(`⏳ 監視対象要素はまだ満員: ${location}${target.timeText}`);\n            }\n            else {\n                console.log(`❓ 監視対象要素の状態が不明: ${location}${target.timeText} (isAvailable: ${currentStatus?.isAvailable}, isFull: ${currentStatus?.isFull})`);\n            }\n        }\n        else {\n            // 要素が見つからない場合\n            const location = section2_1.multiTargetManager.getLocationFromSelector(target.tdSelector);\n            console.log(`❌ 監視対象要素が見つかりません: ${location}${target.timeText}`);\n        }\n    }\n    // すべて満員または見つからない場合\n    console.log('⏳ すべての監視対象要素はまだ満員です');\n    return null;\n}\n// 異常終了処理の統一関数\nfunction terminateMonitoring(errorCode, errorMessage) {\n    console.error(`[監視異常終了] ${errorCode}: ${errorMessage}`);\n    // 状態クリア\n    if (cacheManager) {\n        cacheManager.clearTargetSlots();\n        cacheManager.clearMonitoringFlag(); // 監視継続フラグもクリア\n    }\n    // インターバル停止\n    if (section2_1.timeSlotState.monitoringInterval) {\n        clearInterval(section2_1.timeSlotState.monitoringInterval);\n        section2_1.timeSlotState.monitoringInterval = null;\n    }\n    // UI状態リセット\n    safeCall('resetMonitoringUI');\n    safeCall('updateMainButtonDisplay', 'idle');\n    // エラー表示\n    safeCall('showErrorMessage', errorMessage);\n    // 状態初期化\n    section2_1.timeSlotState.mode = 'idle';\n    section2_1.timeSlotState.isMonitoring = false;\n    section2_1.multiTargetManager.clearAll();\n    section2_1.timeSlotState.retryCount = 0;\n}\n// 監視バリデーション関数群\nfunction checkTargetElementExists(targetInfo) {\n    const element = (0, section4_1.findSameTdElement)(targetInfo);\n    if (!element) {\n        terminateMonitoring('ERROR_TARGET_NOT_FOUND', `監視対象の時間帯 ${targetInfo.timeText} が見つかりません`);\n        return false;\n    }\n    return true;\n}\nasync function checkTimeSlotTableExistsAsync() {\n    const table = document.querySelector(section4_1.timeSlotSelectors.timeSlotContainer);\n    if (!table) {\n        // テーブルが見つからない場合、カレンダークリックを試行\n        console.log('⚠️ 時間帯テーブルが見つからないため、カレンダークリックを試行します');\n        const calendarClicked = await safeCall('tryClickCalendarForTimeSlot');\n        if (calendarClicked) {\n            // カレンダークリック後、再度テーブルをチェック\n            const tableAppeared = await waitForTimeSlotTable(3000);\n            if (tableAppeared) {\n                console.log('✅ カレンダークリック後にテーブルが表示されました');\n                return true;\n            }\n        }\n        terminateMonitoring('ERROR_TABLE_NOT_FOUND', '時間帯選択テーブルが見つかりません（カレンダークリック後も表示されず）');\n        return false;\n    }\n    return true;\n}\nfunction validatePageLoaded() {\n    // URL確認\n    if (!window.location.href.includes('ticket_visiting_reservation')) {\n        terminateMonitoring('ERROR_WRONG_PAGE', '予期しないページに遷移しました');\n        return false;\n    }\n    // 基本要素の存在確認\n    const mainContent = document.querySelector('#__next');\n    if (!mainContent) {\n        terminateMonitoring('ERROR_PAGE_LOAD_FAILED', 'ページの読み込みが完了していません');\n        return false;\n    }\n    return true;\n}\nfunction checkMaxReloads(currentCount) {\n    const MAX_RELOAD_COUNT = 100; // 50分間（30秒×100回）\n    if (currentCount >= MAX_RELOAD_COUNT) {\n        terminateMonitoring('ERROR_MAX_RETRIES_REACHED', `最大試行回数 ${MAX_RELOAD_COUNT} に達しました`);\n        return false;\n    }\n    return true;\n}\n// ============================================================================\n\n\n//# sourceURL=webpack://expo2025-extension/./src-modules/section5.ts?\n}");

/***/ }),

/***/ "./src-modules/section6.ts":
/*!*********************************!*\
  !*** ./src-modules/section6.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setUpdateMonitoringTargetsDisplay = exports.setCanStartReservation = exports.setEntranceReservationHelper = exports.setCacheManagerForSection6 = void 0;\nexports.getCurrentSelectedCalendarDate = getCurrentSelectedCalendarDate;\nexports.clickCalendarDate = clickCalendarDate;\nexports.tryClickCalendarForTimeSlot = tryClickCalendarForTimeSlot;\nexports.showErrorMessage = showErrorMessage;\nexports.resetMonitoringUI = resetMonitoringUI;\nexports.selectTimeSlotAndStartReservation = selectTimeSlotAndStartReservation;\nexports.stopSlotMonitoring = stopSlotMonitoring;\nexports.getCurrentEntranceConfig = getCurrentEntranceConfig;\nexports.resetPreviousSelection = resetPreviousSelection;\nexports.disableOtherMonitorButtons = disableOtherMonitorButtons;\nexports.enableAllMonitorButtons = enableAllMonitorButtons;\nexports.disableAllMonitorButtons = disableAllMonitorButtons;\nexports.clearExistingMonitorButtons = clearExistingMonitorButtons;\nexports.getCurrentTableContent = getCurrentTableContent;\nexports.shouldUpdateMonitorButtons = shouldUpdateMonitorButtons;\nexports.restoreSelectionAfterUpdate = restoreSelectionAfterUpdate;\nexports.updateMainButtonDisplay = updateMainButtonDisplay;\nexports.getCurrentMode = getCurrentMode;\nexports.updateStatusBadge = updateStatusBadge;\nexports.getTargetDisplayInfo = getTargetDisplayInfo;\nexports.startReloadCountdown = startReloadCountdown;\nexports.stopReloadCountdown = stopReloadCountdown;\nexports.setPageLoadingState = setPageLoadingState;\nexports.isInterruptionAllowed = isInterruptionAllowed;\nexports.restoreFromCache = restoreFromCache;\n// Section 2からのimport\nconst section2_1 = __webpack_require__(/*! ./section2 */ \"./src-modules/section2.ts\");\n// Section 4からのimport\nconst section4_1 = __webpack_require__(/*! ./section4 */ \"./src-modules/section4.ts\");\n// Section 5からのimport\nconst section5_1 = __webpack_require__(/*! ./section5 */ \"./src-modules/section5.ts\");\n// 【6. カレンダー・UI状態管理】\n// ============================================================================\n// 依存注入用の参照\nlet cacheManager = null;\nlet entranceReservationHelper = null;\nlet canStartReservation = null;\nlet updateMonitoringTargetsDisplayFn = null;\n// cacheManagerを設定するヘルパー関数\nconst setCacheManagerForSection6 = (cm) => {\n    cacheManager = cm;\n};\nexports.setCacheManagerForSection6 = setCacheManagerForSection6;\n// entranceReservationHelperを設定するヘルパー関数\nconst setEntranceReservationHelper = (helper) => {\n    entranceReservationHelper = helper;\n};\nexports.setEntranceReservationHelper = setEntranceReservationHelper;\n// canStartReservationを設定するヘルパー関数\nconst setCanStartReservation = (fn) => {\n    canStartReservation = fn;\n};\nexports.setCanStartReservation = setCanStartReservation;\n// updateMonitoringTargetsDisplayを設定するヘルパー関数\nconst setUpdateMonitoringTargetsDisplay = (fn) => {\n    updateMonitoringTargetsDisplayFn = fn;\n};\nexports.setUpdateMonitoringTargetsDisplay = setUpdateMonitoringTargetsDisplay;\n// 時間帯表示のためのカレンダー自動クリック機能\n// 現在選択されているカレンダー日付を取得\nfunction getCurrentSelectedCalendarDate() {\n    try {\n        // 安定したセレクタで選択済み要素を検索\n        const selectedSelectors = [\n            '[aria-pressed=\"true\"] time[datetime]',\n            '[class*=\"selector_date\"] time[datetime]'\n        ];\n        for (const selector of selectedSelectors) {\n            const timeElement = document.querySelector(selector);\n            if (timeElement) {\n                const datetime = timeElement.getAttribute('datetime');\n                // console.log(`📅 現在選択中のカレンダー日付: ${datetime} (${selector})`);\n                return datetime;\n            }\n        }\n        // さらなるフォールバック: 任意のaria-pressed=\"true\"要素内のtime要素\n        const anySelected = document.querySelectorAll('[aria-pressed=\"true\"]');\n        for (const el of anySelected) {\n            const timeElement = el.querySelector('time[datetime]');\n            if (timeElement) {\n                const datetime = timeElement.getAttribute('datetime');\n                console.log(`📅 現在選択中のカレンダー日付（フォールバック）: ${datetime}`);\n                return datetime;\n            }\n        }\n        console.log('⚠️ 選択中のカレンダー日付が見つかりません');\n        // デバッグ: 利用可能なカレンダー要素を表示\n        const allCalendarElements = document.querySelectorAll('[role=\"button\"][aria-pressed]');\n        console.log(`📅 利用可能なカレンダー要素数: ${allCalendarElements.length}`);\n        allCalendarElements.forEach((el, i) => {\n            const pressed = el.getAttribute('aria-pressed');\n            const timeEl = el.querySelector('time');\n            const datetime = timeEl ? timeEl.getAttribute('datetime') : 'N/A';\n            console.log(`  ${i + 1}. aria-pressed=\"${pressed}\" datetime=\"${datetime}\"`);\n        });\n        return null;\n    }\n    catch (error) {\n        console.error('❌ カレンダー日付取得エラー:', error);\n        return null;\n    }\n}\n// 指定された日付のカレンダーをクリック\nasync function clickCalendarDate(targetDate) {\n    console.log(`📅 指定日付のカレンダークリックを試行: ${targetDate}`);\n    try {\n        // 指定日付のカレンダー要素を検索（実際のHTML構造に基づく）\n        const timeElement = document.querySelector(`time[datetime=\"${targetDate}\"]`);\n        if (!timeElement) {\n            console.log(`❌ 指定日付のtime要素が見つかりません: ${targetDate}`);\n            // デバッグ: 利用可能なカレンダー要素を表示\n            const allCalendarElements = document.querySelectorAll('time[datetime]');\n            console.log(`🔍 利用可能なカレンダー要素数: ${allCalendarElements.length}`);\n            allCalendarElements.forEach((el, i) => {\n                if (i < 5) { // 最初の5個だけ表示\n                    const datetime = el.getAttribute('datetime');\n                    console.log(`  [${i}] datetime=\"${datetime}\" (${el.tagName})`);\n                }\n            });\n            return false;\n        }\n        // time要素の親のdivボタンを取得\n        const targetElement = timeElement.closest('div[role=\"button\"]');\n        if (!targetElement) {\n            console.log(`❌ 指定日付のボタン要素が見つかりません: ${targetDate}`);\n            return false;\n        }\n        // クリック可能かチェック\n        if (targetElement.getAttribute('tabindex') === '-1' || targetElement.hasAttribute('data-pointer-none')) {\n            console.log(`❌ 指定日付はクリック不可です: ${targetDate}`);\n            return false;\n        }\n        // クリック実行\n        console.log(`🖱️ 日付をクリック: ${targetDate}`);\n        const clickEvent = new MouseEvent('click', {\n            view: window,\n            bubbles: true,\n            cancelable: true\n        });\n        targetElement.dispatchEvent(clickEvent);\n        // クリック結果を待機\n        await new Promise(resolve => setTimeout(resolve, 1500));\n        // クリック成功確認\n        const isNowSelected = targetElement.getAttribute('aria-pressed') === 'true' ||\n            targetElement.classList.contains('selected') ||\n            targetElement.querySelector('time')?.getAttribute('datetime') === targetDate;\n        if (isNowSelected) {\n            console.log('✅ カレンダー日付のクリックが成功しました');\n            return true;\n        }\n        else {\n            console.log('⚠️ カレンダークリックは実行されましたが、選択状態の確認ができません');\n            return true; // 実行は成功したとして進行\n        }\n    }\n    catch (error) {\n        console.error('❌ カレンダー日付クリックエラー:', error);\n        return false;\n    }\n}\nasync function tryClickCalendarForTimeSlot() {\n    console.log('📅 時間帯表示のためのカレンダークリックを試行中...');\n    // 監視対象確認（情報表示のみ）\n    if (section2_1.multiTargetManager.hasTargets()) {\n        const targetTexts = section2_1.multiTargetManager.getTargets().map(t => t.timeText).join(', ');\n        console.log(`🎯 監視対象: ${targetTexts} (${section2_1.multiTargetManager.getCount()}個)`);\n    }\n    // 1. カレンダー要素を検索\n    const calendarSelectors = [\n        '.style_main__calendar__HRSsz',\n        '[class*=\"calendar\"]',\n        'button[role=\"button\"]:has(.style_main__calendar__HRSsz)',\n        'div[class*=\"calendar\"] button'\n    ];\n    let calendarElement = null;\n    for (const selector of calendarSelectors) {\n        calendarElement = document.querySelector(selector);\n        if (calendarElement) {\n            console.log(`📅 カレンダー要素を発見: ${selector}`);\n            break;\n        }\n    }\n    if (!calendarElement) {\n        console.log('❌ カレンダー要素が見つかりません');\n        return false;\n    }\n    // 2. 現在選択されている日付のみを検索\n    const dateSelectors = [\n        '.style_main__calendar__HRSsz button',\n        '.style_main__calendar__HRSsz [role=\"button\"]',\n        '[class*=\"calendar\"] button:not([disabled])',\n        '[class*=\"date\"]:not([disabled])'\n    ];\n    let clickableDate = null;\n    // 現在選択されている日付を探す（これのみが対象）\n    for (const selector of dateSelectors) {\n        const dates = document.querySelectorAll(selector);\n        for (const date of dates) {\n            if (date.classList.contains('selected') ||\n                date.classList.contains('active') ||\n                date.getAttribute('aria-selected') === 'true') {\n                clickableDate = date;\n                console.log(`📅 現在選択中の日付を発見: ${date.textContent?.trim()}`);\n                break;\n            }\n        }\n        if (clickableDate)\n            break;\n    }\n    // ユーザーが選択した日付のみがクリック対象\n    if (!clickableDate) {\n        console.log('❌ ユーザーが選択した日付が見つかりません');\n        console.log('💡 現在選択中の日付のみクリック可能です');\n        return false;\n    }\n    // 3. 選択中の日付をクリック\n    try {\n        console.log(`🖱️ 日付をクリック: \"${clickableDate.textContent?.trim()}\"`);\n        // マウスイベントを発火\n        const clickEvent = new MouseEvent('click', {\n            view: window,\n            bubbles: true,\n            cancelable: true\n        });\n        clickableDate.dispatchEvent(clickEvent);\n        // 少し待機してクリック結果を確認\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        console.log('✅ カレンダー日付のクリックを実行しました');\n        return true;\n    }\n    catch (error) {\n        console.error('❌ カレンダークリック中にエラー:', error);\n        return false;\n    }\n}\n// エラー表示機能\nfunction showErrorMessage(message) {\n    // 既存のエラーメッセージがあれば削除\n    const existingError = document.getElementById('ytomo-error-message');\n    if (existingError) {\n        existingError.remove();\n    }\n    // エラーメッセージ要素を作成\n    const errorDiv = document.createElement('div');\n    errorDiv.id = 'ytomo-error-message';\n    errorDiv.style.cssText = `\n        position: fixed;\n        top: 20px;\n        right: 20px;\n        background: #ff4444;\n        color: white;\n        padding: 15px;\n        border-radius: 5px;\n        font-size: 14px;\n        z-index: 9999;\n        max-width: 300px;\n        box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n    `;\n    errorDiv.innerHTML = `\n        <div style=\"font-weight: bold; margin-bottom: 5px;\">⚠️ 監視エラー</div>\n        <div>${message}</div>\n        <button onclick=\"this.parentElement.remove()\" style=\"\n            background: transparent;\n            border: 1px solid white;\n            color: white;\n            padding: 5px 10px;\n            margin-top: 10px;\n            border-radius: 3px;\n            cursor: pointer;\n        \">閉じる</button>\n    `;\n    document.body.appendChild(errorDiv);\n    // 10秒後に自動削除\n    setTimeout(() => {\n        if (errorDiv && errorDiv.parentElement) {\n            errorDiv.remove();\n        }\n    }, 10000);\n}\n// 監視UI状態のリセット\nfunction resetMonitoringUI() {\n    // すべての監視ボタンを有効化\n    enableAllMonitorButtons();\n    // 選択中の監視ボタンを元に戻す\n    const selectedButtons = document.querySelectorAll('.ext-ytomo.monitor-btn');\n    selectedButtons.forEach(button => {\n        const span = button.querySelector('span');\n        if (span && span.innerText.startsWith('監視')) {\n            span.innerText = '満員';\n            button.style.background = 'rgb(255, 140, 0)';\n            button.disabled = false;\n        }\n    });\n}\n// 時間帯を自動選択して予約開始\nasync function selectTimeSlotAndStartReservation(slotInfo) {\n    const location = section2_1.multiTargetManager.getLocationFromSelector(slotInfo.targetInfo.tdSelector);\n    console.log(`🎯 時間帯を自動選択します: ${location}${slotInfo.timeText}`);\n    // クリック対象のdl要素を探す\n    let clickTarget = null;\n    // TD要素の場合はdl要素を探す\n    if (slotInfo.element.tagName === 'TD') {\n        clickTarget = slotInfo.element.querySelector('div[role=\"button\"] dl');\n        if (clickTarget) {\n            console.log('🔧 TD要素内のdl要素を発見しました');\n        }\n        else {\n            console.error('❌ TD要素内にdl要素が見つかりません');\n            return;\n        }\n    }\n    else {\n        // TD以外の場合はdl要素を探す\n        clickTarget = slotInfo.element.querySelector('dl');\n        if (!clickTarget) {\n            console.error('❌ 要素内にdl要素が見つかりません');\n            return;\n        }\n    }\n    // 時間帯を確実に選択\n    console.log(`🖱️ dl要素をクリックします: ${clickTarget.tagName}`);\n    // 複数の方法で確実にクリック\n    try {\n        // まず通常のクリック\n        clickTarget.click();\n        // さらにイベントディスパッチでクリック\n        const clickEvent = new MouseEvent('click', {\n            bubbles: true,\n            cancelable: true,\n            view: window\n        });\n        clickTarget.dispatchEvent(clickEvent);\n        console.log(`✅ dl要素のクリック完了`);\n    }\n    catch (error) {\n        console.error(`❌ dl要素クリックエラー:`, error);\n    }\n    // 選択状態確認のため少し待つ\n    await new Promise(resolve => setTimeout(resolve, 500));\n    // 選択状態を確認（ボタン要素の状態をチェック）\n    const buttonElement = slotInfo.element.querySelector('div[role=\"button\"]');\n    const isSelected = buttonElement && (Array.from(buttonElement.classList).some(className => className.includes('style_active__')) ||\n        buttonElement.getAttribute('aria-pressed') === 'true');\n    console.log(`🔍 時間帯選択状態確認: ${isSelected ? '選択済み' : '未選択'}`);\n    if (!isSelected) {\n        console.warn(`⚠️ 時間帯が選択されていません。再試行します`);\n        // 再試行 - dl要素を再度クリック\n        clickTarget.click();\n        await new Promise(resolve => setTimeout(resolve, 300));\n    }\n    // 少し待ってから予約処理開始\n    setTimeout(async () => {\n        console.log('🚀 予約処理を開始します');\n        // 予約開始前に時間帯選択を最終確認\n        const finalButtonElement = slotInfo.element.querySelector('div[role=\"button\"]');\n        const finalCheck = finalButtonElement && (Array.from(finalButtonElement.classList).some(className => className.includes('style_active__')) ||\n            finalButtonElement.getAttribute('aria-pressed') === 'true');\n        console.log(`🔍 予約開始前最終確認: 時間帯選択=${finalCheck ? '✅選択済み' : '❌未選択'}`);\n        if (!finalCheck) {\n            console.error(`❌ 時間帯が選択されていないため予約処理を中止します`);\n            return;\n        }\n        // 監視停止\n        stopSlotMonitoring();\n        // 通常の予約処理を開始\n        const config = getCurrentEntranceConfig();\n        if (config && entranceReservationHelper) {\n            section2_1.entranceReservationState.isRunning = true;\n            const result = await entranceReservationHelper(config);\n            if (result.success && cacheManager) {\n                cacheManager.clearTargetSlots(); // 成功時はキャッシュクリア\n                cacheManager.clearMonitoringFlag(); // 監視継続フラグもクリア\n                console.log('✅ 予約が成功しました！');\n            }\n        }\n    }, 1000);\n}\n// 監視停止（監視対象選択は維持）\nfunction stopSlotMonitoring() {\n    section2_1.timeSlotState.isMonitoring = false;\n    // 監視継続フラグをクリア（手動停止なので継続させない）\n    if (cacheManager) {\n        cacheManager.clearMonitoringFlag();\n    }\n    // リロードカウントダウンも確実に停止\n    stopReloadCountdown();\n    // 監視対象が設定されている場合は選択状態に戻す\n    if (section2_1.multiTargetManager.hasTargets()) {\n        section2_1.timeSlotState.mode = 'selecting';\n    }\n    else {\n        section2_1.timeSlotState.mode = 'idle';\n    }\n    if (section2_1.timeSlotState.monitoringInterval) {\n        clearInterval(section2_1.timeSlotState.monitoringInterval);\n        section2_1.timeSlotState.monitoringInterval = null;\n    }\n    // 監視ボタンを有効化（操作可能に戻す）\n    enableAllMonitorButtons();\n    // メインボタンの表示を更新\n    updateMainButtonDisplay();\n    console.log('⏹️ 時間帯監視を停止しました（監視対象選択は維持）');\n}\n// 現在の設定を取得（ヘルパー関数）\nfunction getCurrentEntranceConfig() {\n    // 既存の設定と同じものを返す\n    return {\n        selectors: {\n            submit: \"#__next > div > div > main > div > div.style_main__add_cart_button__DCOw8 > button\",\n            change: \"body > div > div > div > div > div > div > button\",\n            success: \"#reservation_modal_title\",\n            failure: \"#reservation_fail_modal_title\",\n            close: \"body > div.style_buy-modal__1JZtS > div > div > div > div > ul > li > a\"\n        },\n        selectorTexts: {\n            change: \"来場日時を変更する\"\n        },\n        timeouts: {\n            waitForSubmit: 5000,\n            waitForResponse: 10000,\n            waitForClose: 3000,\n            retryInterval: 1000\n        },\n        randomSettings: {\n            minCheckInterval: 500,\n            checkRandomRange: 200,\n            minClickDelay: 500,\n            clickRandomRange: 200,\n            minRetryDelay: 1000,\n            retryRandomRange: 300\n        }\n    };\n}\n// 前の選択をリセット\nfunction resetPreviousSelection() {\n    // すべての監視対象をクリア\n    section2_1.multiTargetManager.clearAll();\n    // ボタンの表示を「満員」に戻す\n    (0, section5_1.updateAllMonitorButtonPriorities)();\n}\n// 他の監視ボタンを無効化（複数監視対象対応版）\nfunction disableOtherMonitorButtons(selectedTimeText, selectedTdSelector) {\n    const allMonitorButtons = document.querySelectorAll('.monitor-btn');\n    allMonitorButtons.forEach(button => {\n        const targetTime = button.getAttribute('data-target-time') || '';\n        const buttonTd = button.closest('td[data-gray-out]');\n        const buttonTdSelector = buttonTd ? (0, section4_1.generateUniqueTdSelector)(buttonTd) : '';\n        // 同じ時間+位置でない場合は無効化\n        if (!(targetTime === selectedTimeText && buttonTdSelector === selectedTdSelector)) {\n            button.style.opacity = '0.5';\n            button.style.cursor = 'not-allowed';\n            button.disabled = true;\n        }\n    });\n}\n// 全ての監視ボタンを有効化\nfunction enableAllMonitorButtons() {\n    const allMonitorButtons = document.querySelectorAll('.monitor-btn');\n    allMonitorButtons.forEach(button => {\n        const span = button.querySelector('span');\n        // すべてのボタンを有効化\n        button.style.opacity = '1';\n        button.style.cursor = 'pointer';\n        button.disabled = false;\n        // 監視対象のボタンは緑色を維持\n        if (span && span.innerText.startsWith('監視')) {\n            button.style.background = 'rgb(0, 104, 33)';\n        }\n        // ツールチップをクリア\n        button.title = '';\n    });\n    console.log('✅ すべての監視ボタンを有効化しました（選択中も含む）');\n}\n// 全ての監視ボタンを無効化（監視実行中用）\nfunction disableAllMonitorButtons() {\n    const allMonitorButtons = document.querySelectorAll('.monitor-btn');\n    allMonitorButtons.forEach(button => {\n        button.style.opacity = '0.5';\n        button.style.cursor = 'not-allowed';\n        button.disabled = true;\n        // ツールチップで理由を表示\n        button.title = '監視実行中のため操作できません';\n    });\n    console.log('🔒 すべての監視ボタンを無効化しました（監視実行中）');\n}\n// 既存の監視ボタンをクリア（日付変更時など）\nfunction clearExistingMonitorButtons() {\n    const existingButtons = document.querySelectorAll('.monitor-btn');\n    console.log(`${existingButtons.length}個の既存監視ボタンをクリアします`);\n    existingButtons.forEach(button => {\n        button.remove();\n    });\n}\n// 現在のテーブル内容を取得（変化検出用）\nfunction getCurrentTableContent() {\n    const tables = document.querySelectorAll('table');\n    let content = '';\n    tables.forEach(table => {\n        const timeSlots = table.querySelectorAll('td div[role=\"button\"]');\n        timeSlots.forEach(slot => {\n            const timeText = slot.querySelector('dt span')?.textContent?.trim();\n            const disabled = slot.getAttribute('data-disabled');\n            const pressed = slot.getAttribute('aria-pressed');\n            if (timeText && (timeText.includes(':') || timeText.includes('時'))) {\n                content += `${timeText}-${disabled}-${pressed}|`;\n            }\n        });\n    });\n    return content;\n}\n// 監視ボタンの更新が必要かチェック\nfunction shouldUpdateMonitorButtons() {\n    const analysis = (0, section5_1.analyzeTimeSlots)();\n    const existingButtons = document.querySelectorAll('.monitor-btn');\n    console.log(`満員時間帯数: ${analysis.full.length}, 既存ボタン数: ${existingButtons.length}`);\n    // 満員時間帯の数と既存ボタン数が異なる場合は更新が必要\n    if (analysis.full.length !== existingButtons.length) {\n        console.log('📊 満員時間帯数と監視ボタン数が不一致');\n        return true;\n    }\n    // 満員時間帯がない場合はボタンも不要\n    if (analysis.full.length === 0) {\n        console.log('📭 満員時間帯なし、ボタン不要');\n        return false;\n    }\n    // 各満員時間帯に対応するボタンが存在するかチェック\n    const fullTimeTexts = analysis.full.map(slot => slot.timeText);\n    const buttonTimeTexts = Array.from(existingButtons).map(btn => btn.getAttribute('data-target-time') || '');\n    const missingButtons = fullTimeTexts.filter(time => !buttonTimeTexts.includes(time));\n    const extraButtons = buttonTimeTexts.filter(time => !fullTimeTexts.includes(time));\n    if (missingButtons.length > 0) {\n        console.log('📌 不足している監視ボタン:', missingButtons);\n        return true;\n    }\n    if (extraButtons.length > 0) {\n        console.log('🗑️ 不要な監視ボタン:', extraButtons);\n        return true;\n    }\n    console.log('✅ 監視ボタンは適切に配置されています');\n    return false;\n}\n// 日付変更後の選択状態復元\nfunction restoreSelectionAfterUpdate() {\n    if (!section2_1.multiTargetManager.hasTargets())\n        return;\n    const targets = section2_1.multiTargetManager.getTargets();\n    const targetTexts = targets.map(t => t.timeText).join(', ');\n    console.log(`選択状態を復元中: ${targetTexts}`);\n    // 該当する時間帯の監視ボタンを探して選択状態にする\n    const monitorButtons = document.querySelectorAll('.monitor-btn');\n    let restoredCount = 0;\n    targets.forEach(target => {\n        monitorButtons.forEach(button => {\n            const buttonTargetTime = button.getAttribute('data-target-time') || '';\n            const buttonTdElement = button.closest('td[data-gray-out]');\n            const buttonTdSelector = buttonTdElement ? (0, section4_1.generateUniqueTdSelector)(buttonTdElement) : '';\n            // 時間+位置で一致するかチェック\n            if (buttonTargetTime === target.timeText && buttonTdSelector === target.tdSelector) {\n                const span = button.querySelector('span');\n                if (span) {\n                    // 監視対象リストでの位置を取得\n                    const allTargets = section2_1.multiTargetManager.getTargets();\n                    const targetIndex = allTargets.findIndex(t => t.timeText === target.timeText && t.tdSelector === target.tdSelector);\n                    if (targetIndex >= 0) {\n                        const priority = targetIndex + 1;\n                        span.innerText = `監視${priority}`;\n                    }\n                    else {\n                        span.innerText = '監視1'; // フォールバック\n                    }\n                    button.style.background = 'rgb(0, 104, 33)';\n                    restoredCount++;\n                    console.log(`✅ 選択状態を復元しました: ${target.timeText}`);\n                }\n            }\n        });\n    });\n    if (restoredCount === 0) {\n        console.log(`⚠️ 対象時間帯が見つからないため選択状態をリセット: ${targetTexts}`);\n        // 対象時間帯がない場合は状態をリセット\n        section2_1.multiTargetManager.clearAll();\n        section2_1.timeSlotState.mode = 'idle';\n        if (cacheManager) {\n            cacheManager.clearTargetSlots();\n        }\n    }\n    updateMainButtonDisplay();\n}\n// メインボタンの表示更新（FAB形式対応）\nfunction updateMainButtonDisplay(forceMode = null) {\n    const fabButton = document.querySelector('#ytomo-main-fab');\n    const statusBadge = document.querySelector('#ytomo-status-badge');\n    if (fabButton && statusBadge) {\n        const span = fabButton.querySelector('span');\n        if (span) {\n            const currentMode = forceMode || getCurrentMode();\n            // デバッグ情報\n            const targetTexts = section2_1.multiTargetManager.hasTargets() ? section2_1.multiTargetManager.getTargets().map(t => t.timeText).join(', ') : 'なし';\n            // console.log(`🔄 FAB更新: mode=${currentMode}, targetSlots=${targetTexts}, stateMode=${timeSlotState.mode}, isMonitoring=${timeSlotState.isMonitoring}`);\n            // console.log(`🔍 getCurrentMode判定: loading=${pageLoadingState?.isLoading}, monitoring=${timeSlotState.isMonitoring}, reservationRunning=${entranceReservationState.isRunning}, hasTargets=${multiTargetManager.hasTargets()}, modeSelecting=${timeSlotState.mode === 'selecting'}`);\n            switch (currentMode) {\n                case 'monitoring':\n                    // 監視実行中 - 中断可能かどうかで表示を区別\n                    if (!isInterruptionAllowed()) {\n                        // 中断不可期間（リロード直前）\n                        span.innerText = '継続\\n中断';\n                        fabButton.style.background = 'rgb(220, 53, 69) !important'; // 赤色\n                        fabButton.style.opacity = '0.6 !important';\n                        fabButton.style.cursor = 'not-allowed !important';\n                        fabButton.title = '監視継続中断（リロード直前のため中断不可）';\n                        fabButton.disabled = true;\n                    }\n                    else {\n                        // 通常の中断可能期間\n                        span.innerText = '監視\\n中断';\n                        fabButton.style.background = 'rgb(255, 140, 0) !important'; // オレンジ色\n                        fabButton.style.opacity = '0.9 !important';\n                        fabButton.style.cursor = 'pointer !important';\n                        fabButton.title = '監視中断（クリックで監視を停止）';\n                        fabButton.disabled = false;\n                    }\n                    updateStatusBadge('monitoring');\n                    break;\n                case 'reservation-running':\n                    // 予約実行中\n                    span.innerText = '予約\\n中断';\n                    fabButton.style.background = 'rgb(255, 140, 0) !important'; // オレンジ色\n                    fabButton.style.opacity = '0.9 !important'; // 通常の透明度\n                    fabButton.style.cursor = 'pointer !important';\n                    fabButton.title = '予約中断';\n                    fabButton.disabled = false; // 有効化\n                    updateStatusBadge('reservation-running');\n                    break;\n                case 'selecting':\n                    // 監視対象設定済み、開始待ち\n                    console.log(`✅ selecting ケース実行: 監視予約開始として有効化`);\n                    span.innerText = '監視予約\\n開始';\n                    fabButton.style.setProperty('background', 'rgb(0, 104, 33)', 'important'); // 強制適用\n                    fabButton.style.setProperty('opacity', '0.9', 'important');\n                    fabButton.style.setProperty('cursor', 'pointer', 'important');\n                    fabButton.style.setProperty('pointer-events', 'auto', 'important');\n                    fabButton.title = '監視予約開始';\n                    fabButton.disabled = false; // 有効化\n                    fabButton.removeAttribute('disabled'); // HTML属性も削除\n                    // クラスによる干渉も除去\n                    fabButton.classList.remove('disabled');\n                    updateStatusBadge('selecting');\n                    break;\n                case 'found-available':\n                    // 利用可能検出後\n                    span.innerText = '予約\\n実行中';\n                    fabButton.style.background = 'rgb(0, 200, 0) !important'; // 明るい緑色\n                    fabButton.style.opacity = '0.6 !important'; // より透明に\n                    fabButton.style.cursor = 'not-allowed !important';\n                    fabButton.title = '見つかりました！予約try中...';\n                    fabButton.disabled = true; // 実行中は無効化\n                    updateStatusBadge('found-available');\n                    break;\n                case 'loading':\n                    // 読み込み中\n                    span.innerText = '読み込み\\n中';\n                    fabButton.style.background = 'rgb(108, 117, 125) !important'; // グレー色\n                    fabButton.style.opacity = '0.6 !important'; // より透明に\n                    fabButton.style.cursor = 'not-allowed !important';\n                    fabButton.title = '情報読み込み中...';\n                    fabButton.disabled = true; // 読み込み中は無効化\n                    updateStatusBadge('loading');\n                    break;\n                case 'idle':\n                default:\n                    console.log(`🔄 idle ケース実行`);\n                    // 監視対象が設定されている場合は selecting モードになるはずだが、\n                    // 念のため idle でも監視対象の有無を確認\n                    if (section2_1.multiTargetManager.hasTargets()) {\n                        // 監視対象設定済み - selectingモードに移行すべき\n                        console.log(`✅ idle内で監視対象検出: 監視予約開始として有効化`);\n                        span.innerText = '監視予約\\n開始';\n                        fabButton.style.background = 'rgb(0, 104, 33) !important'; // 緑色\n                        fabButton.style.opacity = '0.9 !important';\n                        fabButton.style.cursor = 'pointer !important';\n                        fabButton.title = '監視予約開始';\n                        fabButton.disabled = false; // 有効化\n                        fabButton.removeAttribute('disabled'); // HTML属性も削除\n                        fabButton.style.pointerEvents = 'auto !important'; // クリック有効化\n                        updateStatusBadge('selecting');\n                    }\n                    else {\n                        // 通常の予約開始 - 条件に応じてdisabled状態を制御\n                        span.innerText = '予約\\n開始';\n                        const canStart = canStartReservation ? canStartReservation() : false;\n                        if (canStart) {\n                            // 予約開始可能\n                            fabButton.style.background = 'rgb(0, 104, 33) !important'; // 緑色\n                            fabButton.style.opacity = '0.9 !important';\n                            fabButton.style.cursor = 'pointer !important';\n                            fabButton.title = '予約開始';\n                            fabButton.disabled = false; // 有効化\n                            fabButton.removeAttribute('disabled'); // HTML属性も削除\n                            fabButton.style.pointerEvents = 'auto !important'; // クリック有効化\n                            updateStatusBadge('idle');\n                        }\n                        else {\n                            // 条件未満足 - disabled状態\n                            const selectedDate = getCurrentSelectedCalendarDate();\n                            const hasTimeSlotTable = (0, section5_1.checkTimeSlotTableExistsSync)();\n                            if (!selectedDate || !hasTimeSlotTable) {\n                                // カレンダー未選択または時間帯テーブル未表示\n                                fabButton.title = '待機中（カレンダーで日付を選択してください）';\n                            }\n                            else {\n                                // テーブルはあるが他の条件が満たされていない\n                                fabButton.title = '時間帯を選択し、来場日時設定ボタンが有効になるまでお待ちください';\n                            }\n                            fabButton.style.background = 'rgb(128, 128, 128) !important'; // グレー色\n                            fabButton.style.opacity = '0.9 !important';\n                            fabButton.style.cursor = 'not-allowed !important';\n                            fabButton.disabled = true; // 無効化\n                            fabButton.setAttribute('disabled', 'disabled'); // HTML属性も設定\n                            fabButton.style.pointerEvents = 'none !important'; // CSS レベルでもクリック無効化\n                            updateStatusBadge('waiting');\n                        }\n                    }\n                    break;\n            }\n        }\n    }\n}\n// 現在のモードを取得するヘルパー関数\nfunction getCurrentMode() {\n    if (section2_1.pageLoadingState && section2_1.pageLoadingState.isLoading) {\n        return 'loading';\n    }\n    else if (section2_1.timeSlotState.isMonitoring) {\n        return 'monitoring';\n    }\n    else if (section2_1.entranceReservationState.isRunning) {\n        return 'reservation-running';\n    }\n    else if (section2_1.multiTargetManager.hasTargets() && section2_1.timeSlotState.mode === 'selecting') {\n        return 'selecting';\n    }\n    else {\n        return 'idle';\n    }\n}\n// ステータスバッジの更新\nfunction updateStatusBadge(mode) {\n    const statusBadge = document.querySelector('#ytomo-status-badge');\n    if (!statusBadge)\n        return;\n    let message = '';\n    let bgColor = 'rgba(0, 0, 0, 0.8)';\n    switch (mode) {\n        case 'monitoring':\n            message = '監視実行中';\n            if (section2_1.reloadCountdownState.secondsRemaining !== null && section2_1.reloadCountdownState.secondsRemaining !== undefined) {\n                if (section2_1.reloadCountdownState.secondsRemaining <= 3) {\n                    message = `監視中\\nリロード: ${section2_1.reloadCountdownState.secondsRemaining}秒`;\n                    bgColor = 'rgba(255, 0, 0, 0.9)'; // 赤色（中断不可）\n                }\n                else {\n                    message = `監視中\\nリロード: ${section2_1.reloadCountdownState.secondsRemaining}秒`;\n                    bgColor = 'rgba(255, 140, 0, 0.9)'; // オレンジ色\n                }\n            }\n            else {\n                bgColor = 'rgba(255, 140, 0, 0.9)'; // オレンジ色\n            }\n            break;\n        case 'reservation-running':\n            // 経過時間と回数を表示\n            const elapsedMinutes = section2_1.entranceReservationState.startTime ?\n                Math.floor((Date.now() - section2_1.entranceReservationState.startTime) / 60000) : 0;\n            const attempts = section2_1.entranceReservationState.attempts;\n            message = `予約実行中\\n${elapsedMinutes}分 ${attempts}回`;\n            bgColor = 'rgba(255, 140, 0, 0.9)'; // オレンジ色\n            break;\n        case 'selecting':\n            message = '監視準備完了';\n            bgColor = 'rgba(0, 104, 33, 0.9)'; // 緑色\n            break;\n        case 'found-available':\n            message = '空きあり検出！\\n予約実行中';\n            bgColor = 'rgba(0, 200, 0, 0.9)'; // 明るい緑色\n            break;\n        case 'loading':\n            message = '情報読み込み中...';\n            bgColor = 'rgba(108, 117, 125, 0.9)'; // グレー色\n            break;\n        case 'waiting':\n            message = '待機中';\n            bgColor = 'rgba(128, 128, 128, 0.9)'; // グレー色\n            break;\n        case 'idle':\n        default:\n            message = '待機中';\n            bgColor = 'rgba(0, 0, 0, 0.8)'; // 黒色\n            break;\n    }\n    if (message) {\n        statusBadge.innerText = message;\n        statusBadge.style.background = bgColor;\n        statusBadge.style.display = 'block';\n        statusBadge.style.whiteSpace = 'pre-line'; // 改行を有効にする\n    }\n    else {\n        statusBadge.style.display = 'none';\n    }\n}\n// 監視/予約対象の表示情報を取得（簡潔版）\nfunction getTargetDisplayInfo() {\n    const targets = section2_1.multiTargetManager.getTargets();\n    if (targets.length === 0) {\n        return '不明';\n    }\n    const selectedDate = getCurrentSelectedCalendarDate();\n    // 各監視対象の東西を個別に判定（東/西時間の形式で統一）\n    if (targets.length > 1) {\n        const timeLocationTexts = targets.map(target => {\n            const location = section2_1.multiTargetManager.getLocationFromSelector(target.tdSelector);\n            return `${location}${target.timeText || '不明'}`;\n        }).join('\\n');\n        if (selectedDate) {\n            const date = new Date(selectedDate);\n            const dateStr = `${date.getMonth() + 1}/${date.getDate()}`;\n            return `${dateStr}\\n${timeLocationTexts}`;\n        }\n        else {\n            return timeLocationTexts;\n        }\n    }\n    else {\n        // 単一監視対象の場合\n        const target = targets[0];\n        const location = section2_1.multiTargetManager.getLocationFromSelector(target.tdSelector);\n        const timeText = target.timeText || '不明';\n        if (selectedDate) {\n            const date = new Date(selectedDate);\n            const dateStr = `${date.getMonth() + 1}/${date.getDate()}`;\n            return `${dateStr} ${location}${timeText}`;\n        }\n        else {\n            return `${location}${timeText}`;\n        }\n    }\n}\n// カウントダウン開始関数\nfunction startReloadCountdown(seconds = 30) {\n    stopReloadCountdown(); // 既存のカウントダウンを停止\n    section2_1.reloadCountdownState.totalSeconds = seconds;\n    section2_1.reloadCountdownState.secondsRemaining = seconds;\n    section2_1.reloadCountdownState.startTime = Date.now();\n    console.log(`🔄 リロードカウントダウン開始: ${seconds}秒`);\n    // 即座に一度UI更新\n    updateMainButtonDisplay();\n    section2_1.reloadCountdownState.countdownInterval = window.setInterval(() => {\n        if (section2_1.reloadCountdownState.secondsRemaining !== null) {\n            section2_1.reloadCountdownState.secondsRemaining--;\n            // UI更新（カウントダウン表示のみ）\n            updateMainButtonDisplay();\n            if (section2_1.reloadCountdownState.secondsRemaining <= 0) {\n                stopReloadCountdown();\n                // リロード実行はreloadTimerに任せる（重複実行を防ぐ）\n                console.log('🔄 カウントダウン完了（リロードはreloadTimerが実行）');\n            }\n        }\n    }, 1000);\n}\n// カウントダウン停止関数\nfunction stopReloadCountdown() {\n    if (section2_1.reloadCountdownState.countdownInterval) {\n        clearInterval(section2_1.reloadCountdownState.countdownInterval);\n        section2_1.reloadCountdownState.countdownInterval = null;\n    }\n    // リロードタイマーも停止\n    if (section2_1.reloadCountdownState.reloadTimer) {\n        clearTimeout(section2_1.reloadCountdownState.reloadTimer);\n        section2_1.reloadCountdownState.reloadTimer = null;\n        console.log('🛑 リロードタイマーを停止しました（中断による停止）');\n    }\n    section2_1.reloadCountdownState.secondsRemaining = null;\n    section2_1.reloadCountdownState.startTime = null;\n}\n// ページ読み込み状態を設定\nfunction setPageLoadingState(isLoading) {\n    section2_1.pageLoadingState.isLoading = isLoading;\n    if (isLoading) {\n        section2_1.pageLoadingState.startTime = Date.now();\n    }\n    else {\n        section2_1.pageLoadingState.startTime = null;\n    }\n    updateMainButtonDisplay();\n}\n// 中断操作が許可されているかチェック\nfunction isInterruptionAllowed() {\n    // リロード直前3秒間は中断不可（時間を短縮して中断可能期間を延長）\n    const isCountdownActive = section2_1.reloadCountdownState.secondsRemaining !== null && section2_1.reloadCountdownState.secondsRemaining !== undefined;\n    const isNearReload = isCountdownActive && section2_1.reloadCountdownState.secondsRemaining !== null && section2_1.reloadCountdownState.secondsRemaining <= 3;\n    // console.log(`🔍 中断可否チェック: countdown=${reloadCountdownState.secondsRemaining}, active=${isCountdownActive}, nearReload=${isNearReload}`);\n    return !isNearReload;\n}\n// ページ読み込み時のキャッシュ復元\nasync function restoreFromCache() {\n    if (!cacheManager)\n        return;\n    const cached = cacheManager.loadTargetSlots();\n    if (!cached)\n        return;\n    console.log('🔄 キャッシュから複数監視状態を復元中...');\n    // カレンダー読み込み完了を待機\n    const hasCalendar = await (0, section4_1.waitForCalendar)();\n    if (!hasCalendar) {\n        console.log('❌ カレンダーの読み込みがタイムアウトしました');\n        cacheManager.clearTargetSlots();\n        return;\n    }\n    // キャッシュされた日付と現在の日付を比較\n    if (cached.selectedDate) {\n        const currentSelectedDate = getCurrentSelectedCalendarDate();\n        console.log(`📅 比較 - キャッシュ日付: ${cached.selectedDate}, 現在日付: ${currentSelectedDate}`);\n        if (currentSelectedDate !== cached.selectedDate) {\n            console.log('📅 日付が一致しません。キャッシュされた日付に移動します...');\n            const calendarClicked = await clickCalendarDate(cached.selectedDate);\n            if (!calendarClicked) {\n                console.log('❌ 指定日付へのカレンダークリックに失敗しました');\n                console.log('🗑️ 復元不可のためキャッシュをクリアします');\n                cacheManager.clearTargetSlots();\n                return;\n            }\n            // 日付クリック後、テーブル表示を待機\n            console.log('⏰ 日付変更後の時間帯テーブル表示を待機中...');\n            const tableAppeared = await (0, section5_1.waitForTimeSlotTable)(8000);\n            if (!tableAppeared) {\n                console.log('❌ 日付変更後もテーブルが表示されませんでした');\n                console.log('🗑️ 復元不可のためキャッシュをクリアします');\n                cacheManager.clearTargetSlots();\n                return;\n            }\n        }\n        else {\n            console.log('✅ カレンダー日付は一致しています');\n        }\n    }\n    else {\n        console.log('⚠️ キャッシュに日付情報がありません（古いキャッシュ）');\n    }\n    // 時間帯テーブルの存在確認と必要に応じてカレンダークリック\n    const hasTable = await (0, section5_1.checkTimeSlotTableExistsAsync)();\n    if (!hasTable) {\n        console.log('⏰ 時間帯テーブルが見つからないため、現在選択中の日付をクリックします');\n        const calendarClicked = await tryClickCalendarForTimeSlot();\n        if (calendarClicked) {\n            // カレンダークリック後、テーブル表示を待機\n            const tableAppeared = await (0, section5_1.waitForTimeSlotTable)(5000);\n            if (!tableAppeared) {\n                console.log('❌ カレンダークリック後もテーブルが表示されませんでした');\n                console.log('🗑️ 復元不可のためキャッシュをクリアします');\n                cacheManager.clearTargetSlots();\n                return;\n            }\n        }\n        else {\n            console.log('❌ カレンダークリックに失敗しました');\n            console.log('🗑️ 復元不可のためキャッシュをクリアします');\n            cacheManager.clearTargetSlots();\n            return;\n        }\n    }\n    // UI更新を遅延実行（DOM完成後）\n    setTimeout(() => {\n        // 該当する監視ボタンを探して復元\n        let restoredCount = 0;\n        const allMonitorButtons = document.querySelectorAll('.monitor-btn');\n        console.log(`📋 復元対象監視ターゲット: ${cached.targets?.length || 0}個`);\n        // 優先順位順に処理（最優先から順番にチェック）\n        const availableTargets = [];\n        // 各監視対象について状態をチェック\n        cached.targets?.forEach((targetData, index) => {\n            const location = section2_1.multiTargetManager.getLocationFromSelector(targetData.tdSelector);\n            const priority = index + 1;\n            console.log(`📍 復元対象を処理中: ${priority}.${location}${targetData.timeText}`);\n            // まず同一td要素を見つける\n            const tdElement = (0, section4_1.findSameTdElement)(targetData);\n            if (!tdElement) {\n                console.log(`❌ td要素が見つかりません: ${location}${targetData.timeText}`);\n                return;\n            }\n            // td要素の現在の状態をチェック\n            const currentStatus = (0, section4_1.extractTdStatus)(tdElement);\n            if (currentStatus && currentStatus.isAvailable) {\n                console.log(`🎉 監視対象が空きありに変化！: ${priority}.${location}${targetData.timeText}`);\n                availableTargets.push({\n                    ...targetData,\n                    priority,\n                    location,\n                    tdElement,\n                    currentStatus\n                });\n            }\n            else {\n                // まだ満員の場合、監視ボタンを探す\n                let targetButton = null;\n                allMonitorButtons.forEach(button => {\n                    const buttonTime = button.getAttribute('data-target-time') || '';\n                    const buttonTd = button.closest('td[data-gray-out]');\n                    const buttonTdSelector = buttonTd ? (0, section4_1.generateUniqueTdSelector)(buttonTd) : '';\n                    // 時間+位置で一致するかチェック\n                    if (buttonTime === targetData.timeText && buttonTdSelector === targetData.tdSelector) {\n                        targetButton = button;\n                    }\n                });\n                if (targetButton) {\n                    console.log(`📍 復元対象の監視ボタンを発見: ${location}${targetData.timeText}`);\n                    // 状態復元（複数監視対象対応）\n                    const restoredSlotInfo = {\n                        timeText: targetData.timeText,\n                        tdSelector: targetData.tdSelector,\n                        positionInfo: targetData.positionInfo,\n                        status: targetData.status\n                    };\n                    // 複数監視対象マネージャーに追加\n                    const added = section2_1.multiTargetManager.addTarget(restoredSlotInfo);\n                    if (added && targetButton) {\n                        // ボタンの表示を更新\n                        const span = targetButton.querySelector('span');\n                        if (span) {\n                            // 監視対象での優先順位を取得\n                            const allTargets = section2_1.multiTargetManager.getTargets();\n                            const targetIndex = allTargets.findIndex(t => t.timeText === targetData.timeText && t.tdSelector === targetData.tdSelector);\n                            if (targetIndex >= 0) {\n                                const priority = targetIndex + 1;\n                                span.innerText = `監視${priority}`;\n                            }\n                            else {\n                                span.innerText = '監視1'; // フォールバック\n                            }\n                            targetButton.style.background = 'rgb(0, 104, 33)';\n                            targetButton.disabled = false; // クリックで解除可能\n                        }\n                        restoredCount++;\n                        console.log(`✅ 監視状態を復元: ${location}${targetData.timeText}`);\n                    }\n                    else {\n                        console.log(`⚠️ 監視対象の追加に失敗: ${location}${targetData.timeText}`);\n                    }\n                }\n                else {\n                    console.log(`⚠️ 復元対象の監視ボタンが見つかりません: ${location}${targetData.timeText}`);\n                }\n            }\n        });\n        // 空きありの監視対象が見つかった場合は優先順位で自動選択\n        if (availableTargets.length > 0) {\n            // 最優先（priority最小）の監視対象を選択\n            const topPriority = availableTargets.sort((a, b) => a.priority - b.priority)[0];\n            console.log(`🎉🚀 最優先の空きあり監視対象を発見！自動選択開始: ${topPriority.priority}.${topPriority.location}${topPriority.timeText}`);\n            // 監視継続フラグをクリア（自動選択するため）\n            if (cacheManager) {\n                cacheManager.clearMonitoringFlag();\n            }\n            // 空きありになった要素を自動選択して予約開始\n            const slotInfo = {\n                element: topPriority.currentStatus.element, // div[role=\"button\"]要素\n                timeText: topPriority.currentStatus.timeText,\n                status: 'available',\n                targetInfo: topPriority\n            };\n            // 監視状態とキャッシュをクリア\n            if (cacheManager) {\n                cacheManager.clearTargetSlots();\n            }\n            section2_1.multiTargetManager.clearAll();\n            setTimeout(async () => {\n                await selectTimeSlotAndStartReservation(slotInfo);\n            }, 1000);\n            return; // 復元処理終了\n        }\n        // 復元結果の処理\n        if (restoredCount > 0) {\n            section2_1.timeSlotState.retryCount = cached.retryCount || 0;\n            section2_1.timeSlotState.mode = 'selecting';\n            // メインボタンの表示更新\n            updateMainButtonDisplay();\n            // FAB監視対象表示の更新\n            if (updateMonitoringTargetsDisplayFn) {\n                updateMonitoringTargetsDisplayFn();\n            }\n            console.log(`✅ ${restoredCount}個の監視状態を復元完了 (試行回数: ${cached.retryCount})`);\n            // 監視継続フラグをチェックして監視を再開\n            const shouldContinueMonitoring = cacheManager?.getAndClearMonitoringFlag();\n            if (shouldContinueMonitoring) {\n                console.log('🔄 監視継続フラグが有効です。監視を自動再開します...');\n                setTimeout(() => {\n                    (0, section5_1.startSlotMonitoring)();\n                }, 3000); // DOM安定化を待ってから監視開始\n            }\n            else {\n                console.log('🛑 監視継続フラグが無効または期限切れです。監視は再開されません');\n            }\n        }\n        else {\n            // 復元できた対象がない場合\n            console.log('❌ 復元できた監視対象がありません');\n            const shouldContinueMonitoring = cacheManager?.getAndClearMonitoringFlag();\n            if (shouldContinueMonitoring) {\n                console.log('🔄 監視継続フラグが有効です。カレンダー自動クリックを試行します...');\n                // キャッシュクリアのヘルパー関数\n                const clearTargetAndState = () => {\n                    if (cacheManager) {\n                        cacheManager.clearTargetSlots();\n                    }\n                    section2_1.multiTargetManager.clearAll();\n                    section2_1.timeSlotState.mode = 'idle';\n                    section2_1.timeSlotState.retryCount = 0;\n                    updateMainButtonDisplay();\n                    console.log('✅ キャッシュクリア完了');\n                };\n                // カレンダー日付をクリックして時間帯テーブルを表示させる\n                if (cached.selectedDate) {\n                    clickCalendarDate(cached.selectedDate).then(calendarClicked => {\n                        if (calendarClicked) {\n                            console.log('📅 カレンダー自動クリック成功。監視対象復元を再試行します...');\n                            // 少し待ってから再試行\n                            setTimeout(async () => {\n                                // 全ての監視対象について再試行\n                                let retryRestoredCount = 0;\n                                cached.targets?.forEach((targetData) => {\n                                    const retryTargetElement = (0, section4_1.findSameTdElement)(targetData);\n                                    if (!retryTargetElement)\n                                        return;\n                                    const retryStatus = (0, section4_1.extractTdStatus)(retryTargetElement);\n                                    if (retryStatus) {\n                                        const retrySlotInfo = {\n                                            timeText: targetData.timeText,\n                                            tdSelector: targetData.tdSelector,\n                                            positionInfo: targetData.positionInfo,\n                                            status: retryStatus.isFull ? 'full' : retryStatus.isAvailable ? 'available' : 'unknown'\n                                        };\n                                        const added = section2_1.multiTargetManager.addTarget(retrySlotInfo);\n                                        if (added) {\n                                            retryRestoredCount++;\n                                        }\n                                    }\n                                });\n                                if (retryRestoredCount > 0) {\n                                    section2_1.timeSlotState.mode = 'selecting';\n                                    console.log(`✅ ${retryRestoredCount}個の監視対象を再試行で復元成功`);\n                                    updateMainButtonDisplay();\n                                    (0, section5_1.startSlotMonitoring)();\n                                }\n                                else {\n                                    console.log('❌ 再試行でも監視対象が見つかりません。キャッシュをクリアします');\n                                    clearTargetAndState();\n                                }\n                            }, 2000);\n                        }\n                        else {\n                            console.log('❌ カレンダー自動クリック失敗。キャッシュをクリアします');\n                            clearTargetAndState();\n                        }\n                    });\n                }\n                else {\n                    console.log('❌ 保存された日付情報がありません。キャッシュをクリアします');\n                    clearTargetAndState();\n                }\n            }\n            else {\n                console.log('🗑️ 監視継続フラグが無効です。古いキャッシュをクリアします');\n                if (cacheManager) {\n                    cacheManager.clearTargetSlots();\n                }\n                section2_1.multiTargetManager.clearAll();\n                section2_1.timeSlotState.mode = 'idle';\n                section2_1.timeSlotState.retryCount = 0;\n                updateMainButtonDisplay();\n                console.log('✅ キャッシュクリア完了');\n            }\n        }\n    }, 2000);\n}\n// ============================================================================\n\n\n//# sourceURL=webpack://expo2025-extension/./src-modules/section6.ts?\n}");

/***/ }),

/***/ "./src-modules/section7.ts":
/*!*********************************!*\
  !*** ./src-modules/section7.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setCacheManagerForSection7 = void 0;\nexports.createEntranceReservationUI = createEntranceReservationUI;\nexports.updateMonitoringTargetsDisplay = updateMonitoringTargetsDisplay;\nexports.getCurrentReservationTarget = getCurrentReservationTarget;\nexports.checkVisitTimeButtonState = checkVisitTimeButtonState;\nexports.checkTimeSlotSelected = checkTimeSlotSelected;\nexports.canStartReservation = canStartReservation;\nexports.checkInitialState = checkInitialState;\nexports.startCalendarWatcher = startCalendarWatcher;\nexports.handleCalendarChange = handleCalendarChange;\nexports.removeAllMonitorButtons = removeAllMonitorButtons;\nexports.entranceReservationHelper = entranceReservationHelper;\n// Section 1からのimport\nconst section1_1 = __webpack_require__(/*! ./section1 */ \"./src-modules/section1.ts\");\n// Section 2からのimport\nconst section2_1 = __webpack_require__(/*! ./section2 */ \"./src-modules/section2.ts\");\n// Section 4からのimport\nconst section4_1 = __webpack_require__(/*! ./section4 */ \"./src-modules/section4.ts\");\n// Section 5からのimport\nconst section5_1 = __webpack_require__(/*! ./section5 */ \"./src-modules/section5.ts\");\n// Section 6からのimport  \nconst section6_1 = __webpack_require__(/*! ./section6 */ \"./src-modules/section6.ts\");\n// 【7. FAB・メインUI】\n// ============================================================================\n// 依存注入用のcacheManager参照\nlet cacheManager = null;\n// cacheManagerを設定するヘルパー関数\nconst setCacheManagerForSection7 = (cm) => {\n    cacheManager = cm;\n};\nexports.setCacheManagerForSection7 = setCacheManagerForSection7;\n// ステータス表示用のヘルパー関数\nfunction showStatus(message, color = 'white') {\n    const statusBadge = document.querySelector('#ytomo-status-badge');\n    if (!statusBadge)\n        return;\n    statusBadge.innerText = message;\n    statusBadge.style.background = color === 'green' ? 'rgba(0, 128, 0, 0.9)' :\n        color === 'red' ? 'rgba(255, 0, 0, 0.9)' :\n            color === 'orange' ? 'rgba(255, 140, 0, 0.9)' :\n                color === 'blue' ? 'rgba(0, 104, 33, 0.9)' :\n                    'rgba(0, 0, 0, 0.8)';\n    statusBadge.style.display = 'block';\n    // 一定時間後に自動で隠す（エラー、成功、中断メッセージ以外）\n    if (color !== 'red' && color !== 'green' && color !== 'orange') {\n        setTimeout(() => {\n            statusBadge.style.display = 'none';\n        }, 3000);\n    }\n}\nfunction createEntranceReservationUI(config) {\n    // 既存のFABがあれば削除\n    const existingFab = document.getElementById('ytomo-fab-container');\n    if (existingFab) {\n        existingFab.remove();\n    }\n    // FABコンテナを作成（右下固定）\n    const fabContainer = document.createElement('div');\n    fabContainer.id = 'ytomo-fab-container';\n    fabContainer.style.cssText = `\n        position: fixed !important;\n        bottom: 24px !important;\n        right: 24px !important;\n        z-index: 10000 !important;\n        display: flex !important;\n        flex-direction: column !important;\n        gap: 12px !important;\n        align-items: flex-end !important;\n        pointer-events: auto !important;\n    `;\n    // メインFABボタンを作成\n    const fabButton = document.createElement('button');\n    fabButton.id = 'ytomo-main-fab';\n    fabButton.classList.add('ext-ytomo');\n    fabButton.style.cssText = `\n        width: 56px !important;\n        height: 56px !important;\n        border-radius: 50% !important;\n        background: rgb(0, 104, 33) !important;\n        color: white !important;\n        border: none !important;\n        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), 0 2px 8px rgba(0, 0, 0, 0.2) !important;\n        border: 3px solid rgba(255, 255, 255, 0.2) !important;\n        cursor: pointer !important;\n        display: flex !important;\n        align-items: center !important;\n        justify-content: center !important;\n        font-size: 14px !important;\n        font-weight: bold !important;\n        transition: all 0.3s ease !important;\n        position: relative !important;\n        overflow: hidden !important;\n        pointer-events: auto !important;\n        opacity: 0.9 !important;\n    `;\n    // FABボタンのテキスト/アイコン\n    const fabIcon = document.createElement('span');\n    fabIcon.classList.add('ext-ytomo');\n    fabIcon.style.cssText = `\n        font-size: 12px !important;\n        text-align: center !important;\n        line-height: 1.2 !important;\n        white-space: nowrap !important;\n        pointer-events: none !important;\n    `;\n    fabIcon.innerText = '待機中';\n    fabButton.appendChild(fabIcon);\n    // 初期状態で無効化\n    fabButton.disabled = true;\n    fabButton.style.opacity = '0.6';\n    fabButton.style.cursor = 'not-allowed';\n    // ホバー効果（強化版）\n    fabButton.addEventListener('mouseenter', () => {\n        fabButton.style.transform = 'scale(1.15)';\n        fabButton.style.boxShadow = '0 8px 25px rgba(0, 0, 0, 0.5), 0 4px 12px rgba(0, 0, 0, 0.3)';\n        fabButton.style.borderWidth = '4px';\n    });\n    fabButton.addEventListener('mouseleave', () => {\n        fabButton.style.transform = 'scale(1)';\n        fabButton.style.boxShadow = '0 6px 20px rgba(0, 0, 0, 0.4), 0 2px 8px rgba(0, 0, 0, 0.2)';\n        fabButton.style.borderWidth = '3px';\n    });\n    // 監視対象表示エリア（目立つ表示）\n    const monitoringTargetsDisplay = document.createElement('div');\n    monitoringTargetsDisplay.id = 'ytomo-monitoring-targets';\n    monitoringTargetsDisplay.style.cssText = `\n        background: linear-gradient(135deg, rgba(0, 104, 33, 0.95), rgba(0, 150, 50, 0.95)) !important;\n        color: white !important;\n        padding: 8px 12px !important;\n        border-radius: 12px !important;\n        font-size: 12px !important;\n        font-weight: bold !important;\n        text-align: center !important;\n        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3) !important;\n        border: 2px solid rgba(255, 255, 255, 0.3) !important;\n        min-width: 120px !important;\n        max-width: 200px !important;\n        display: none !important;\n        white-space: pre-line !important;\n        overflow: visible !important;\n        text-overflow: clip !important;\n        pointer-events: auto !important;\n        cursor: pointer !important;\n        transition: all 0.3s ease !important;\n    `;\n    monitoringTargetsDisplay.title = '監視対象一覧（クリックで詳細表示）';\n    // ホバー効果\n    monitoringTargetsDisplay.addEventListener('mouseenter', () => {\n        monitoringTargetsDisplay.style.transform = 'scale(1.05)';\n        monitoringTargetsDisplay.style.boxShadow = '0 4px 14px rgba(0, 0, 0, 0.4)';\n    });\n    monitoringTargetsDisplay.addEventListener('mouseleave', () => {\n        monitoringTargetsDisplay.style.transform = 'scale(1)';\n        monitoringTargetsDisplay.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';\n    });\n    // ステータス表示（コンパクト）\n    const statusBadge = document.createElement('div');\n    statusBadge.id = 'ytomo-status-badge';\n    statusBadge.style.cssText = `\n        background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(40, 40, 40, 0.9)) !important;\n        color: white !important;\n        padding: 8px 16px !important;\n        border-radius: 20px !important;\n        font-size: 12px !important;\n        font-weight: bold !important;\n        white-space: pre-line !important;\n        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3), 0 2px 6px rgba(0, 0, 0, 0.2) !important;\n        border: 2px solid rgba(255, 255, 255, 0.15) !important;\n        display: none !important;\n        pointer-events: none !important;\n        text-align: center !important;\n        line-height: 1.3 !important;\n    `;\n    statusBadge.innerText = '待機中';\n    // メインFABボタンにイベントリスナーを設定\n    fabButton.addEventListener('click', async (event) => {\n        // disabled状態の場合はクリックを完全に無視\n        if (fabButton.disabled || fabButton.hasAttribute('disabled')) {\n            console.log('⚠️ ボタンがdisabledのためクリックを無視します');\n            event.preventDefault();\n            event.stopPropagation();\n            event.stopImmediatePropagation();\n            return false;\n        }\n        // 追加のstyle確認（CSS disabled状態もチェック）\n        if (fabButton.style.pointerEvents === 'none') {\n            console.log('⚠️ pointer-events:noneのためクリックを無視します');\n            event.preventDefault();\n            event.stopPropagation();\n            event.stopImmediatePropagation();\n            return false;\n        }\n        // 中断不可期間のチェック\n        if (!(0, section6_1.isInterruptionAllowed)()) {\n            console.log('⚠️ リロード直前のため中断できません');\n            showStatus('リロード直前のため中断できません', 'red');\n            return;\n        }\n        // 実行中の場合は中断処理\n        if (section2_1.timeSlotState.isMonitoring) {\n            console.log('監視を中断します');\n            (0, section6_1.stopSlotMonitoring)();\n            // ステータスは中断を示すメッセージを表示（消さない）\n            showStatus('監視中断', 'orange');\n            (0, section6_1.updateMainButtonDisplay)();\n            return;\n        }\n        if (section2_1.entranceReservationState.isRunning) {\n            console.log('予約処理を中断します');\n            section2_1.entranceReservationState.shouldStop = true;\n            showStatus('予約処理を中断中...', 'orange');\n            return;\n        }\n        // 監視対象が設定されている場合は監視開始\n        if (section2_1.multiTargetManager.hasTargets() && section2_1.timeSlotState.mode === 'selecting') {\n            // 即座にUI更新してから監視開始\n            (0, section6_1.updateMainButtonDisplay)();\n            await (0, section5_1.startSlotMonitoring)();\n            return;\n        }\n        // 通常の予約処理\n        section2_1.entranceReservationState.isRunning = true;\n        section2_1.entranceReservationState.shouldStop = false;\n        section2_1.entranceReservationState.startTime = Date.now();\n        section2_1.entranceReservationState.attempts = 0;\n        showStatus('予約処理実行中...', 'blue');\n        (0, section6_1.updateMainButtonDisplay)();\n        updateMonitoringTargetsDisplay(); // 予約対象を表示\n        try {\n            const result = await entranceReservationHelper(config);\n            if (result.success) {\n                showStatus(`🎉 予約成功！(${result.attempts}回試行)`, 'green');\n                if (cacheManager) {\n                    cacheManager.clearTargetSlots(); // 成功時はキャッシュクリア\n                    cacheManager.clearMonitoringFlag(); // 監視継続フラグもクリア\n                }\n            }\n            else {\n                showStatus(`予約失敗 (${result.attempts}回試行)`, 'red');\n            }\n        }\n        catch (error) {\n            console.error('予約処理エラー:', error);\n            showStatus(`エラー: ${error.message}`, 'red');\n        }\n        finally {\n            section2_1.entranceReservationState.isRunning = false;\n            section2_1.entranceReservationState.startTime = null;\n            section2_1.entranceReservationState.attempts = 0;\n            (0, section6_1.updateMainButtonDisplay)();\n            updateMonitoringTargetsDisplay(); // 予約終了時に表示更新\n        }\n    });\n    // disabled状態でのクリックを確実に防ぐため、キャプチャーフェーズでも処理\n    fabButton.addEventListener('click', (event) => {\n        if (fabButton.disabled || fabButton.hasAttribute('disabled') || fabButton.style.pointerEvents === 'none') {\n            console.log('🚫 キャプチャーフェーズでdisabledクリックを阻止');\n            event.preventDefault();\n            event.stopPropagation();\n            event.stopImmediatePropagation();\n            return false;\n        }\n    }, true); // useCapture = true\n    // FABコンテナに要素を追加（上から順：監視対象→ステータス→ボタン）\n    fabContainer.appendChild(monitoringTargetsDisplay);\n    fabContainer.appendChild(statusBadge);\n    fabContainer.appendChild(fabButton);\n    // DOMに追加（body直下）\n    document.body.appendChild(fabContainer);\n    console.log('✅ FAB形式の予約UIを作成しました');\n    // 初期状態を判定してFABを更新\n    setTimeout(() => {\n        checkInitialState();\n    }, 500);\n    // カレンダー変更監視を開始\n    startCalendarWatcher();\n}\n// 監視対象表示を更新\nfunction updateMonitoringTargetsDisplay() {\n    const targetsDisplay = document.querySelector('#ytomo-monitoring-targets');\n    if (!targetsDisplay)\n        return;\n    // 予約実行中の対象を取得\n    const reservationTarget = getCurrentReservationTarget();\n    const targets = section2_1.multiTargetManager.getTargets();\n    // 予約実行中の場合は予約対象を表示\n    if (section2_1.entranceReservationState.isRunning && reservationTarget) {\n        targetsDisplay.innerText = `予約対象:\\n${reservationTarget}`;\n        targetsDisplay.style.display = 'block';\n        targetsDisplay.style.background = 'linear-gradient(135deg, rgba(0, 104, 33, 0.9), rgba(0, 150, 50, 0.9))';\n        targetsDisplay.title = `現在予約実行中の対象: ${reservationTarget}`;\n        return;\n    }\n    // 監視対象がない場合は非表示\n    if (targets.length === 0) {\n        targetsDisplay.style.display = 'none';\n        return;\n    }\n    // 監視対象を東西+時間形式で表示\n    const targetTexts = targets.map((target, index) => {\n        const location = section2_1.multiTargetManager.getLocationFromSelector(target.tdSelector);\n        const priority = index + 1;\n        return `${priority}.${location}${target.timeText}`;\n    });\n    targetsDisplay.innerText = `監視対象:\\n${targetTexts.join('\\n')}`;\n    targetsDisplay.style.display = 'block';\n    targetsDisplay.style.background = 'linear-gradient(135deg, rgba(255, 140, 0, 0.9), rgba(255, 180, 0, 0.9))';\n    // 詳細なツールチップ\n    const detailText = targets.map((target, index) => {\n        const location = section2_1.multiTargetManager.getLocationFromSelector(target.tdSelector);\n        const priority = index + 1;\n        return `${priority}. ${location}${target.timeText}`;\n    }).join('\\n');\n    targetsDisplay.title = `監視対象 (${targets.length}個):\\n${detailText}\\n\\nクリックで詳細表示`;\n}\n// 現在の予約対象時間帯を取得\nfunction getCurrentReservationTarget() {\n    // 選択された時間帯を探す\n    const selectedSlot = document.querySelector('td[data-gray-out] div[role=\"button\"][aria-pressed=\"true\"]');\n    if (!selectedSlot)\n        return null;\n    const timeSpan = selectedSlot.querySelector('dt span');\n    if (!timeSpan)\n        return null;\n    const timeText = timeSpan.textContent.trim();\n    // 東西判定\n    const tdElement = selectedSlot.closest('td[data-gray-out]');\n    const tdSelector = (0, section4_1.generateUniqueTdSelector)(tdElement);\n    const location = section2_1.multiTargetManager.getLocationFromSelector(tdSelector);\n    return `${location}${timeText}`;\n}\n// 来場日時設定ボタンの状態をチェック\nfunction checkVisitTimeButtonState() {\n    const visitTimeButton = document.querySelector('button.basic-btn.type2.style_full__ptzZq');\n    if (!visitTimeButton) {\n        console.log('⚠️ 来場日時設定ボタンが見つかりません');\n        return false;\n    }\n    const isDisabled = visitTimeButton.hasAttribute('disabled') || visitTimeButton.disabled;\n    console.log(`🔘 来場日時設定ボタン: ${isDisabled ? '無効' : '有効'}`);\n    return !isDisabled;\n}\n// 時間帯が選択されているかチェック\nfunction checkTimeSlotSelected() {\n    // 選択された時間帯（aria-pressed=\"true\"）をチェック\n    const selectedTimeSlot = document.querySelector(section4_1.timeSlotSelectors.selectedSlot);\n    if (!selectedTimeSlot) {\n        console.log('⚠️ 時間帯が選択されていません');\n        return false;\n    }\n    // 選択された時間帯が満員でないかチェック\n    const tdElement = selectedTimeSlot.closest('td');\n    if (!tdElement)\n        return false;\n    const status = (0, section4_1.extractTdStatus)(tdElement);\n    if (status && status.isFull) {\n        console.log('⚠️ 選択された時間帯は満員です');\n        return false;\n    }\n    console.log(`✅ 時間帯選択済み: ${status?.timeText || 'unknown'}`);\n    return true;\n}\n// 予約開始可能かどうかの総合判定\nfunction canStartReservation() {\n    const hasTimeSlotTable = (0, section5_1.checkTimeSlotTableExistsSync)();\n    const isTimeSlotSelected = checkTimeSlotSelected();\n    const isVisitTimeButtonEnabled = checkVisitTimeButtonState();\n    console.log(`📊 予約開始条件チェック:`);\n    console.log(`  - 時間帯テーブル: ${hasTimeSlotTable ? '✅' : '❌'}`);\n    console.log(`  - 時間帯選択: ${isTimeSlotSelected ? '✅' : '❌'}`);\n    console.log(`  - 来場日時ボタン有効: ${isVisitTimeButtonEnabled ? '✅' : '❌'}`);\n    return hasTimeSlotTable && isTimeSlotSelected && isVisitTimeButtonEnabled;\n}\n// 初期状態をチェックしてFABを適切に設定\nfunction checkInitialState() {\n    console.log('🔍 初期状態をチェック中...');\n    // カレンダーで日付が選択されているかチェック\n    const selectedDate = (0, section6_1.getCurrentSelectedCalendarDate)();\n    const hasTimeSlotTable = (0, section5_1.checkTimeSlotTableExistsSync)();\n    console.log(`📅 選択日付: ${selectedDate || 'なし'}`);\n    console.log(`🗓️ 時間帯テーブル: ${hasTimeSlotTable ? 'あり' : 'なし'}`);\n    if (selectedDate && hasTimeSlotTable) {\n        // 時間帯テーブルがある場合、予約開始可能かチェック\n        const canStart = canStartReservation();\n        console.log(`✅ 日付選択済み、時間帯テーブル表示中 - ${canStart ? '予約開始可能' : '条件未満'}`);\n        // FABボタンの状態を設定\n        const fabButton = document.querySelector('#ytomo-main-fab');\n        const fabIcon = fabButton?.querySelector('span');\n        if (fabButton && fabIcon) {\n            // 常に「予約開始」と表示\n            fabIcon.innerText = '予約\\n開始';\n            if (canStart) {\n                // 予約開始可能\n                fabButton.style.background = 'rgb(0, 104, 33) !important';\n                fabButton.style.opacity = '0.9 !important';\n                fabButton.style.cursor = 'pointer !important';\n                fabButton.disabled = false;\n                fabButton.title = '予約開始';\n            }\n            else {\n                // 条件未満足 - disabled状態（グレー色）\n                fabButton.style.background = 'rgb(128, 128, 128) !important';\n                fabButton.style.opacity = '0.9 !important';\n                fabButton.style.cursor = 'not-allowed !important';\n                fabButton.disabled = true;\n                fabButton.title = '時間帯を選択し、来場日時設定ボタンが有効になるまでお待ちください';\n            }\n        }\n        // ステータスも更新\n        (0, section6_1.updateStatusBadge)(canStart ? 'idle' : 'waiting');\n    }\n    else {\n        // カレンダー未選択または時間帯テーブル未表示の場合は待機中のまま\n        console.log('⏳ カレンダー未選択または時間帯テーブル未表示 - 待機中を維持');\n        (0, section6_1.updateStatusBadge)('idle');\n    }\n}\n// カレンダー変更を監視して監視ボタンを再設置\nfunction startCalendarWatcher() {\n    if (section2_1.calendarWatchState.isWatching)\n        return;\n    section2_1.calendarWatchState.isWatching = true;\n    section2_1.calendarWatchState.currentSelectedDate = (0, section6_1.getCurrentSelectedCalendarDate)();\n    console.log('📅 カレンダー変更監視を開始');\n    // MutationObserverでカレンダー変更・時間帯選択・ボタン状態変更を検出\n    section2_1.calendarWatchState.observer = new MutationObserver((mutations) => {\n        let shouldUpdate = false;\n        mutations.forEach((mutation) => {\n            // 1. カレンダーのaria-pressed属性の変更を検出\n            if (mutation.type === 'attributes' &&\n                (mutation.attributeName === 'aria-pressed' ||\n                    mutation.attributeName === 'class')) {\n                const element = mutation.target;\n                if (element.matches && element.matches('[role=\"button\"][aria-pressed]') &&\n                    element.querySelector('time[datetime]')) {\n                    shouldUpdate = true;\n                }\n            }\n            // 2. 時間帯選択の変更を検出\n            if (mutation.type === 'attributes' &&\n                mutation.attributeName === 'aria-pressed') {\n                const element = mutation.target;\n                if (element.matches && element.matches('td[data-gray-out] div[role=\"button\"]')) {\n                    shouldUpdate = true;\n                }\n            }\n            // 3. 来場日時設定ボタンのdisabled属性変更を検出\n            if (mutation.type === 'attributes' &&\n                mutation.attributeName === 'disabled') {\n                const element = mutation.target;\n                if (element.matches && element.matches('button.basic-btn.type2.style_full__ptzZq')) {\n                    shouldUpdate = true;\n                }\n            }\n        });\n        if (shouldUpdate) {\n            // 少し遅延して処理（DOM更新完了を待つ）\n            setTimeout(() => {\n                handleCalendarChange();\n            }, 500);\n        }\n    });\n    // カレンダー要素全体を監視\n    const observeTarget = document.body;\n    section2_1.calendarWatchState.observer.observe(observeTarget, {\n        attributes: true,\n        subtree: true,\n        attributeFilter: ['aria-pressed', 'class', 'disabled']\n    });\n}\n// カレンダー変更・状態変更時の処理\nfunction handleCalendarChange() {\n    const newSelectedDate = (0, section6_1.getCurrentSelectedCalendarDate)();\n    const calendarDateChanged = newSelectedDate !== section2_1.calendarWatchState.currentSelectedDate;\n    if (calendarDateChanged) {\n        console.log(`📅 カレンダー日付変更を検出: ${section2_1.calendarWatchState.currentSelectedDate} → ${newSelectedDate}`);\n        // 監視実行中は日付変更を無視\n        if (section2_1.timeSlotState.isMonitoring) {\n            console.log('⚠️ 監視実行中のため日付変更を無視します');\n            return;\n        }\n        section2_1.calendarWatchState.currentSelectedDate = newSelectedDate;\n        // 既存の監視状態をクリア（日付が変わったため）\n        if (section2_1.multiTargetManager.hasTargets() && !section2_1.timeSlotState.isMonitoring) {\n            console.log('📅 日付変更により監視対象をクリア');\n            section2_1.multiTargetManager.clearAll();\n            section2_1.timeSlotState.mode = 'idle';\n            if (cacheManager) {\n                cacheManager.clearTargetSlots();\n            }\n        }\n        // 監視ボタンを再設置\n        setTimeout(() => {\n            removeAllMonitorButtons();\n            (0, section5_1.analyzeAndAddMonitorButtons)();\n            // FABボタンの状態も更新\n            (0, section6_1.updateMainButtonDisplay)();\n            console.log('🔄 監視ボタンとFABを再設置しました');\n        }, 1000); // 時間帯テーブル更新を待つ\n    }\n    else {\n        // 日付は変わっていない - 監視ボタンの再設置は不要\n        console.log('📅 日付変更なし - FABボタンの状態のみ更新');\n        // FABボタンの状態のみ更新（監視ボタンは再設置しない）\n        (0, section6_1.updateMainButtonDisplay)();\n    }\n}\n// 既存の監視ボタンをすべて削除\nfunction removeAllMonitorButtons() {\n    const existingButtons = document.querySelectorAll('.monitor-btn.ext-ytomo');\n    existingButtons.forEach(button => button.remove());\n    console.log(`🗑️ 既存の監視ボタンを${existingButtons.length}個削除しました`);\n}\nasync function entranceReservationHelper(config) {\n    const { selectors, selectorTexts, timeouts } = config;\n    let attempts = 0;\n    const maxAttempts = 100;\n    console.log('入場予約補助機能を開始します...');\n    while (attempts < maxAttempts && !section2_1.entranceReservationState.shouldStop) {\n        attempts++;\n        console.log(`試行回数: ${attempts}`);\n        const statusDiv = document.getElementById('reservation-status');\n        if (statusDiv) {\n            statusDiv.innerText = `試行中... (${attempts}回目)`;\n        }\n        try {\n            console.log('1. submitボタンを待機中...');\n            const submitButton = await (0, section1_1.waitForElement)(selectors.submit, timeouts.waitForSubmit, config);\n            if (section2_1.entranceReservationState.shouldStop)\n                break;\n            console.log('submitボタンが見つかりました。クリックします。');\n            // submit押下時に回数を更新\n            section2_1.entranceReservationState.attempts = attempts;\n            await (0, section1_1.clickElement)(submitButton, config);\n            console.log('2. レスポンスを待機中...');\n            const responseSelectors = {\n                change: selectors.change,\n                success: selectors.success,\n                failure: selectors.failure\n            };\n            const response = await (0, section1_1.waitForAnyElement)(responseSelectors, timeouts.waitForResponse, selectorTexts, config);\n            console.log(`レスポンス検出: ${response.key}`);\n            if (section2_1.entranceReservationState.shouldStop)\n                break;\n            if (response.key === 'change') {\n                console.log('changeボタンをクリックします。');\n                await (0, section1_1.clickElement)(response.element, config);\n                console.log('success/failureを待機中...');\n                const finalSelectors = {\n                    success: selectors.success,\n                    failure: selectors.failure\n                };\n                const finalResponse = await (0, section1_1.waitForAnyElement)(finalSelectors, timeouts.waitForResponse, selectorTexts, config);\n                console.log(`最終レスポンス検出: ${finalResponse.key}`);\n                if (finalResponse.key === 'success') {\n                    console.log('🎉 予約成功！処理を終了します。');\n                    return { success: true, attempts };\n                }\n                else {\n                    console.log('予約失敗。closeボタンをクリックして再試行します。');\n                    const closeButton = await (0, section1_1.waitForElement)(selectors.close, timeouts.waitForClose, config);\n                    await (0, section1_1.clickElement)(closeButton, config);\n                    await new Promise(resolve => setTimeout(resolve, (0, section1_1.getRandomWaitTime)(config.randomSettings.minRetryDelay, config.randomSettings.retryRandomRange, config)));\n                }\n            }\n            else if (response.key === 'success') {\n                console.log('🎉 予約成功！処理を終了します。');\n                return { success: true, attempts };\n            }\n            else if (response.key === 'failure') {\n                console.log('予約失敗。closeボタンをクリックして再試行します。');\n                const closeButton = await (0, section1_1.waitForElement)(selectors.close, timeouts.waitForClose, config);\n                await (0, section1_1.clickElement)(closeButton, config);\n                await new Promise(resolve => setTimeout(resolve, (0, section1_1.getRandomWaitTime)(config.randomSettings.minRetryDelay, config.randomSettings.retryRandomRange, config)));\n            }\n        }\n        catch (error) {\n            console.error(`エラーが発生しました (試行 ${attempts}):`, error.message);\n            if (section2_1.entranceReservationState.shouldStop)\n                break;\n            await new Promise(resolve => setTimeout(resolve, (0, section1_1.getRandomWaitTime)(config.randomSettings.minRetryDelay, config.randomSettings.retryRandomRange, config)));\n        }\n    }\n    if (section2_1.entranceReservationState.shouldStop) {\n        console.log('ユーザーによってキャンセルされました。');\n        return { success: false, attempts, cancelled: true };\n    }\n    console.log(`最大試行回数 (${maxAttempts}) に達しました。処理を終了します。`);\n    return { success: false, attempts };\n}\n// ============================================================================\n\n\n//# sourceURL=webpack://expo2025-extension/./src-modules/section7.ts?\n}");

/***/ }),

/***/ "./src-modules/test-export-helper.ts":
/*!*******************************************!*\
  !*** ./src-modules/test-export-helper.ts ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("{\n/**\n * テスト用のエクスポートヘルパー\n * TypeScriptモジュールからテストで必要な関数をCommonJS形式でエクスポート\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// 必要なモジュールをインポート\nconst section2_1 = __webpack_require__(/*! ./section2 */ \"./src-modules/section2.ts\");\nconst section4_1 = __webpack_require__(/*! ./section4 */ \"./src-modules/section4.ts\");\nconst section5_1 = __webpack_require__(/*! ./section5 */ \"./src-modules/section5.ts\");\nconst section6_1 = __webpack_require__(/*! ./section6 */ \"./src-modules/section6.ts\");\nconst section7_1 = __webpack_require__(/*! ./section7 */ \"./src-modules/section7.ts\");\n// CommonJS形式でエクスポート\nmodule.exports = {\n    // Section 2からの状態オブジェクト\n    multiTargetManager: section2_1.multiTargetManager,\n    timeSlotState: section2_1.timeSlotState,\n    // Section 4からの関数\n    generateUniqueTdSelector: section4_1.generateUniqueTdSelector,\n    getTdPositionInfo: section4_1.getTdPositionInfo,\n    findSameTdElement: section4_1.findSameTdElement,\n    extractTdStatus: section4_1.extractTdStatus,\n    timeSlotSelectors: section4_1.timeSlotSelectors,\n    // Section 5からの関数\n    checkTimeSlotTableExistsSync: section5_1.checkTimeSlotTableExistsSync,\n    validatePageLoaded: section5_1.validatePageLoaded,\n    // Section 6からの関数\n    isInterruptionAllowed: section6_1.isInterruptionAllowed,\n    // Section 7からの関数\n    checkVisitTimeButtonState: section7_1.checkVisitTimeButtonState,\n    canStartReservation: section7_1.canStartReservation\n};\n\n\n//# sourceURL=webpack://expo2025-extension/./src-modules/test-export-helper.ts?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src-modules/test-export-helper.ts");
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;