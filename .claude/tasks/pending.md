# 保留中の作業内容

## TypeScript分割実装+1ファイルコンパイル調査 - 2025-08-02

### 背景
現在は全ての機能をindex.js 1ファイルに記述しているが、管理性向上のため以下の方針を検討:
- 機能別にTypeScriptファイルで分割実装
- 最終的に1ファイルにminify+compileして出力
- Chrome拡張として動作する形式を維持

### 調査項目

#### 1. ビルドツール候補
- **Webpack**: Chrome拡張向けの設定、TypeScript対応
- **Rollup**: 軽量、Tree Shaking、単一ファイル出力に適している
- **esbuild**: 高速、TypeScript対応、minify機能
- **Vite**: 開発体験、TypeScript、プラグインエコシステム
- **Parcel**: ゼロ配置、自動最適化

#### 2. TypeScript設定
- `tsconfig.json`設定（target, module, outDir等）
- 型定義ファイル（Chrome拡張API、DOM型）
- strictモード設定
- source map生成（デバッグ用）

#### 3. ファイル分割構造案
```
src/
├── types/
│   ├── index.ts          # 共通型定義
│   ├── chrome-ext.ts     # Chrome拡張型
│   └── dom.ts           # DOM関連型
├── utils/
│   ├── cache-manager.ts  # キャッシュ管理
│   ├── selectors.ts     # セレクタ定義
│   └── dom-utils.ts     # DOM操作ユーティリティ
├── components/
│   ├── calendar.ts      # カレンダー操作
│   ├── time-slots.ts    # 時間帯監視
│   ├── fab-ui.ts        # FABボタンUI
│   └── status-badge.ts  # ステータス表示
├── managers/
│   ├── multi-target.ts  # 複数監視対象管理
│   ├── countdown.ts     # カウントダウン管理
│   └── state.ts         # 状態管理
├── services/
│   ├── monitoring.ts    # 監視サービス
│   ├── reservation.ts   # 予約処理
│   └── auto-reload.ts   # 自動リロード
└── index.ts             # エントリーポイント
```

#### 4. ビルド設定調査
- **入力**: 複数TypeScriptファイル
- **出力**: 単一minified JavaScript
- **要件**:
  - Chrome拡張Content Script形式
  - 外部依存なし（self-contained）
  - minify + uglify
  - TypeScript型チェック
  - 開発時のwatch mode

#### 5. パッケージマネージャー
- npm vs yarn vs pnpm
- 開発依存関係の管理
- scriptsの設定（build, dev, watch）

#### 6. Chrome拡張特有の考慮事項
- Content Security Policy (CSP) 対応
- manifest.json との整合性
- インジェクション方式の維持
- hot reload / 開発体験

#### 7. 具体的な実装パターン
```typescript
// types/index.ts
export interface MonitoringTarget {
  timeText: string;
  tdSelector: string;
  positionInfo: PositionInfo;
  status: string;
}

// managers/multi-target.ts
import { MonitoringTarget } from '../types';

export class MultiTargetManager {
  private targets: MonitoringTarget[] = [];
  
  addTarget(target: MonitoringTarget): boolean {
    // 実装
  }
}

// index.ts
import { MultiTargetManager } from './managers/multi-target';
import { CalendarManager } from './components/calendar';
// ...

// 既存の関数型実装をクラス化または名前空間化
```

#### 8. 移行戦略
- Phase 1: ビルド環境構築
- Phase 2: 型定義の整備
- Phase 3: 段階的な機能分割（カレンダー→監視→UI→...）
- Phase 4: テストの整備
- Phase 5: 既存index.jsとの並行運用

#### 9. メリット・デメリット
**メリット**:
- コードの可読性・保守性向上
- TypeScriptによる型安全性
- 機能別のテスト容易性
- 開発者体験の向上
- 再利用性の向上

**デメリット**:
- ビルド設定の複雑化
- 開発フローの変更
- デバッグの複雑化
- ビルド時間の増加

#### 10. 推奨調査手順
1. esbuild + TypeScript の簡単なPoC実装
2. 既存の一部機能（カレンダー管理）を分割してテスト
3. ビルド設定の最適化
4. 開発ワークフローの確立
5. 全体移行の判断

### 注意事項
- 既存の動作に影響を与えないよう注意
- 段階的な移行で安全性を確保
- ビルド産物のサイズ増加に注意
- Chrome拡張の制限事項を考慮

---

## 監視ボタン押下からカウントダウン開始までの遅延問題 - 2025-08-09

### 問題の詳細
- **症状**: 監視ボタンを押下してからカウントダウンが開始するまで約1秒の遅延がある
- **期待動作**: ボタン押下後即座にカウントダウンが開始される

### 原因分析
監視開始フローに不要な遅延が含まれている：

1. **監視ボタン押下** → `startSlotMonitoring()`呼び出し
2. **500ms待機** → `setTimeout(..., 500)` 
3. **監視チェック処理** → `checkSlotAvailabilityAndReload()`
4. **バリデーション** → 複数のチェック処理
5. **カウントダウン開始** → `scheduleReload()`呼び出し

### 修正案
**現在のシーケンシャル処理:**
```
ボタン押下 → 500ms待機 → 処理実行 → カウントダウン開始
```

**改善後の並行処理:**
```
ボタン押下 → 即座にカウントダウン開始 + 並行して監視処理実行
```

### 具体的な実装変更
1. `startSlotMonitoring()`で即座に`scheduleReload()`を呼び出し
2. カウントダウン開始後に並行して監視チェック処理を実行
3. 500ms遅延を削除または大幅短縮（50-100ms程度）

### 影響範囲
- `entrance-page-monitor.ts`の`startSlotMonitoring()`関数
- カウントダウンUI更新タイミング
- 監視処理の実行順序

### 優先度
中（ユーザー体験の改善）

---

## 自動テストシステムの検討と実装 - 2025-08-12

### 背景
現在のプロジェクトは手動テストに依存しており、以下の課題がある：
- コード変更時の回帰テストが困難
- 複雑な機能（監視→予約移行、効率モード等）の動作保証が不十分
- ブラウザ間・デバイス間の互換性検証が困難
- リファクタリング時の安全性確保が困難

### 必要な自動テストの種類

#### 1. Unit Test（単体テスト）
- **対象**: 各関数・クラス・モジュールの個別機能
- **ツール候補**: Jest, Vitest, Mocha + Chai
- **優先対象**:
  - DOM操作ユーティリティ関数
  - 状態管理ロジック
  - セレクタ生成・要素検出機能
  - キャッシュ管理機能
  - 時刻計算・カウントダウン機能

#### 2. Integration Test（統合テスト）
- **対象**: モジュール間の連携動作
- **重要フロー**:
  - 入場予約: 監視対象設定→監視実行→状態変化検出→予約実行
  - 同行者追加: チケット選択→画面遷移→チケットID入力→追加実行
  - 効率モード: 時刻計算→待機→タイミング調整→クリック実行
  - キャッシュ復元: 保存→リロード→復元→状態継続

#### 3. E2E Test（エンドツーエンドテスト）
- **対象**: 実際のブラウザでの完全な動作フロー
- **ツール候補**: Playwright, Puppeteer, Cypress
- **テストシナリオ**:
  - パビリオン検索→入場予約画面→予約実行
  - 満員時間帯監視→空き検出→自動予約
  - 同行者チケット管理→複数追加→完了確認
  - エラー発生時の適切な回復動作

#### 4. Cross-Browser Test（ブラウザ互換性テスト）
- **対象ブラウザ**: Chrome, Firefox, Safari, Edge
- **対象デバイス**: Desktop, Mobile (iPhone Safari, Android Chrome)
- **重点項目**:
  - iPhone Safariでの同行者ボタン押下問題
  - React入力フィールドの値認識
  - CSS/SCSS表示の一貫性
  - JavaScript実行環境の違い

### 実装アプローチ

#### Phase 1: Unit Test基盤構築
- テスト環境セットアップ（Jest/Vitest）
- TypeScript設定の統合
- モックオブジェクトの準備（DOM, localStorage等）
- 主要関数の基本テスト実装

#### Phase 2: Integration Test実装
- テストデータ・シナリオの設計
- DOM操作テストの自動化
- 状態遷移テストの実装
- キャッシュ・永続化テストの実装

#### Phase 3: E2E Test環境構築
- Playwright/Puppeteerの導入検討
- テスト用万博サイト環境の準備（必要に応じて）
- CI/CD統合の検討（GitHub Actions等）
- テスト実行自動化の設定

#### Phase 4: 継続的品質保証
- Pre-commit hookでの自動テスト実行
- Pull Request時の自動テスト実行
- 定期的な回帰テスト実行
- テストカバレッジ監視

### 技術的考慮事項

#### Chrome拡張機能特有の課題
- Content Script環境でのテスト実行
- DOM注入タイミングの制御
- 拡張機能APIのモック化
- セキュリティ制限下でのテスト実行

#### 万博サイト依存の課題
- 外部サイトDOM構造の変更リスク
- ネットワーク接続に依存するテスト
- サイト負荷を避けたテスト設計
- テスト用データ・環境の準備

### 優先度・実装順序

#### 高優先度（即座実装）
- Unit Test: DOM操作・状態管理の基本機能
- 現在の手動テストの自動化

#### 中優先度（近日実装）
- Integration Test: 主要フローの動作保証
- ブラウザ互換性テストの部分実装

#### 低優先度（将来実装）
- 完全なE2Eテスト環境
- CI/CD統合・自動化

### 期待効果

#### 開発効率向上
- リファクタリング時の安全性確保
- 機能追加時の回帰バグ防止
- コード品質の継続的な向上

#### 信頼性向上
- ユーザー環境での動作保証
- エッジケース・エラーケースの事前発見
- 長期運用時の安定性確保

### 実装コスト見積もり
- **Phase 1**: 2-3日（Unit Test基盤）
- **Phase 2**: 3-5日（Integration Test）
- **Phase 3**: 5-7日（E2E Test環境）
- **Phase 4**: 2-3日（CI/CD統合）

**総計**: 12-18日程度の実装期間を想定

### 注意事項
- 万博サイトの利用規約・負荷配慮
- テスト実行時のサイトへの影響最小化
- 実際のユーザーデータ・操作への影響回避
- テスト環境の適切な分離

---

## パビリオン検索画面 統合予約システム

### 概要
パビリオン検索画面で完結する統合的な予約システムの実装。現在は検索→別画面移動→手動予約の流れだが、これを検索画面内で完全自動化する。

### 主要機能

#### 1. 定期検索と自動予約
- **定期的なパビリオン空き状況チェック**
  - 設定した間隔（5分、10分、30分等）での自動再検索
  - バックグラウンドでの空き状況監視
  - 空きが出た瞬間の即座通知

- **優先予約リスト管理**
  - 複数パビリオンの優先順位設定
  - 希望時間帯の指定（午前/午後/終日）
  - 除外条件の設定（特定時間帯を避ける）

#### 2. 空き時間の取得と表示
- **リアルタイム空き時間表示**
  - 各パビリオンの利用可能時間帯を検索画面に直接表示
  - 混雑状況の可視化（空いている/やや混雑/混雑）
  - 待ち時間予測の表示

- **時間帯別詳細情報**
  - 各時間帯の残り枠数表示
  - 予約取得の難易度表示
  - 過去の予約成功率データ

#### 3. 画面内での予約完了
- **ワンクリック予約**
  - 検索結果から直接予約実行
  - 複数パビリオンの同時予約試行
  - 失敗時の自動リトライ

- **バッチ予約処理**
  - 複数人分の一括予約
  - 同行者情報の事前設定・自動入力
  - グループ予約の最適化

### 技術実装案

#### アーキテクチャ
```
パビリオン検索画面
├── 定期監視システム
│   ├── 空き状況ポーリング
│   ├── 変更検出・通知
│   └── 予約試行トリガー
├── 統合UI
│   ├── 空き時間リアルタイム表示
│   ├── 予約ボタン直接配置
│   └── 進行状況表示
└── 予約実行エンジン
    ├── iframe活用の画面遷移
    ├── 自動入力・送信
    └── 結果判定・報告
```

#### 主要モジュール
- **SearchPageIntegration**: 検索画面での統合機能制御
- **AvailabilityMonitor**: 空き状況の定期監視
- **ReservationOrchestrator**: 複数予約の調整・実行
- **EmbeddedReservationEngine**: iframe内での予約処理
- **NotificationManager**: 空き検出・予約完了通知

### 技術的課題

#### 1. クロスオリジン制約
- **iframe内でのページ操作**
- **別ドメインでの自動処理実行**
- **セッション管理の複雑性**

#### 2. パフォーマンス最適化
- **定期ポーリングの負荷軽減**
- **複数iframe同時実行の制御**
- **メモリ使用量の管理**

#### 3. 万博サイト対応
- **API非公開による画面スクレイピング**
- **予約システムの頻繁な変更対応**
- **アクセス制限・BAN対策**

### 実装優先度

#### Phase 1: 基礎インフラ（高）
- [ ] 検索画面での統合UI基盤
- [ ] iframe活用の予約画面埋め込み
- [ ] 基本的な空き状況取得

#### Phase 2: 監視・通知（中）
- [ ] 定期監視システム
- [ ] 空き検出・通知機能
- [ ] 優先予約リスト管理

#### Phase 3: 自動予約（中）
- [ ] ワンクリック予約機能
- [ ] 複数パビリオン同時処理
- [ ] バッチ予約処理

#### Phase 4: 最適化（低）
- [ ] 予約成功率向上
- [ ] パフォーマンス最適化
- [ ] 高度な設定・カスタマイズ

### 想定される利用シーン

#### 効率的なパビリオン予約
1. **朝の一括チェック**: 1日の始まりに全パビリオンをチェック
2. **昼休み狙い撃ち**: キャンセル多発時間の自動監視
3. **夕方の追加予約**: 当日追加枠の即座取得

#### 団体・グループ利用
1. **家族旅行の計画**: 複数パビリオンの時間調整
2. **企業イベント**: 大人数での効率的予約
3. **友人グループ**: 希望の組み合わせでの最適予約

### 注意事項

#### 倫理的配慮
- **過度なアクセス負荷の回避**
- **他利用者への配慮**
- **万博運営方針の遵守**

#### 技術的制約
- **万博サイトの利用規約遵守**
- **ブラウザセキュリティ制約**
- **拡張機能ストア審査対応**

---

**実装時期**: v2.0.0以降の主要機能として位置づけ
**実装工数**: 大規模（3-6ヶ月の開発期間を想定）
**リスク**: 高（万博サイト変更、技術的制約への対応が必要）