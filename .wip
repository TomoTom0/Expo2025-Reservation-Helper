## 現在の作業: 巨大ソースコード(3798行)の段階的分析・分割アプローチ

### Phase 1: 詳細構造調査と分析

#### 調査対象
- **ファイル**: src/index.js (3,798行)
- **形式**: Chrome拡張UserScript形式
- **対象サイト**: 大阪万博予約システム (パビリオン予約・入場予約)

#### 主要機能ブロック分析

##### 1. 基本機能・ユーティリティ (12-427行)
```
- insert_style(): CSS挿入
- prepare_filter(): 正規表現変換（パビリオン検索用）  
- init_page(): パビリオンページ初期化
- judge_init(), judge_entrance_init(): ページ判定
- init_entrance_page(): 入場予約ページ初期化
- getRandomWaitTime(): ランダム待機時間生成
```

##### 2. 状態管理オブジェクト (495-617行)
```
- entranceReservationState: 入場予約実行状態
- timeSlotState: 時間帯監視状態 (idle/selecting/monitoring/trying)
- multiTargetManager: 複数監視対象管理
- pageLoadingState: ページ読み込み状態
- reloadCountdownState: リロードカウントダウン
- calendarWatchState: カレンダー変更監視
```

##### 3. キャッシュ・永続化システム (620-797行)
```
- cacheManager: localStorage基盤のキャッシュ管理
  - saveTargetSlots(): 監視対象保存
  - restoreTargetSlots(): 監視対象復元
  - clear(): キャッシュクリア
```

##### 4. DOM要素セレクタ・検索 (799-898行)
```
- timeSlotSelectors: 時間帯要素セレクタ定義
- generateUniqueTdSelector(): 一意td要素セレクタ生成
- findSameTdElement(): 同一要素検索
- extractTdStatus(): 要素状態抽出（満員/利用可能判定）
```

##### 5. 時間帯監視・分析システム (900-1870行)
```
- startTimeSlotTableObserver(): 動的テーブル監視
- analyzeAndAddMonitorButtons(): 監視ボタン追加
- analyzeTimeSlots(): 全時間帯状態分析
- createMonitorButton(): 個別監視ボタン作成
- handleMonitorButtonClick(): ボタンクリック処理
- findTargetSlotInPage(): 監視対象検索
- terminateMonitoring(): 異常終了処理
```

##### 6. カレンダー・UI状態管理 (1871-3111行)
```
- getCurrentSelectedCalendarDate(): 選択日付取得
- resetMonitoringUI(): UI状態リセット
- updateMainButtonDisplay(): FABボタン表示更新
- startReloadCountdown(): リロードカウントダウン
- getCurrentMode(): 現在モード取得
```

##### 7. FAB・メインUI (3112-3742行)
```
- createEntranceReservationUI(): FABボタン作成
- updateMonitoringTargetsDisplay(): 監視対象表示更新
- checkVisitTimeButtonState(): 来場日時ボタン状態確認
- startCalendarWatcher(): カレンダー変更監視開始
- handleCalendarChange(): カレンダー変更処理
```

##### 8. ページ判定・初期化 (3743-3798行)
```
- identify_page_type(): URL判定
- trigger_init(): 初期化トリガー
```

#### 重要な技術的特徴

##### DOM監視アーキテクチャ
1. **MutationObserver**: カレンダー変更・時間帯選択変更を検出
2. **動的要素対応**: ページリロード後の同一要素追跡
3. **状態同期**: リロード間でのキャッシュ状態維持

##### 複数監視対象システム
```javascript
// 時間帯 + 位置（東西）での一意性管理
multiTargetManager.addTarget(slotInfo);
multiTargetManager.isSelected(timeText, tdSelector);
```

##### FAB UI パターン
```javascript
// 右下固定FABボタン + 監視対象表示
fabContainer.style.cssText = `
    position: fixed !important;
    bottom: 24px !important; 
    right: 24px !important;
`;
```

### 分析完了の結論

#### 機能モジュール分割案
1. **core/**: 基本ユーティリティ・状態管理
2. **dom/**: DOM操作・セレクタ・要素検索
3. **monitor/**: 時間帯監視・分析システム
4. **ui/**: FAB・ボタン・表示系
5. **cache/**: 永続化・キャッシュ管理
6. **calendar/**: カレンダー監視・変更検出
7. **pavilion/**: パビリオン検索機能
8. **main/**: エントリーポイント・初期化

#### 依存関係分析
- **core** ← すべてのモジュールが依存
- **dom** ← monitor, ui, calendar が依存
- **cache** ← monitor, ui が依存
- **ui** ← calendar が依存

#### Phase 2進行中: テスト作成

#### 問題認識
- 前回作成したブラウザ手動実行テストは実用的でない
- npm testで自動実行できるテスト環境が必要
- 実際のindex.js関数を直接テストする必要
- 分割作業中の品質保証には自動テストが必須

#### 現在の課題
- **テスト環境未構築**: Jest/Vitest等の自動テストフレームワーク未導入
- **実行形式不適切**: ブラウザ手動実行では継続的テスト不可
- **モック依存**: 実際の関数ではなく抽出したモック関数をテスト
- **CI/CD非対応**: 自動化パイプラインに組み込めない

#### 必要な作業
1. **Jest環境構築**: package.json、jest.config.js設定
2. **jsdom環境**: DOM操作テストのためのNode.js DOM環境
3. **実関数テスト**: src/index.jsから直接関数をimportしてテスト
4. **自動実行確認**: npm testでの動作確認

### 事前品質保証フェーズ完了 ✅

#### 完了した作業
1. **Unit Test 3段階実装完了**
   - Phase 1: 純粋関数Unit Test（5関数、26テスト）
   - Phase 2: DOM検索系Unit Test（3関数、5テスト）
   - Phase 3: 判定・検証系Unit Test（5関数、9テスト）

2. **Integration Test基盤構築完了**
   - ヘルパー関数・アサーション関数作成
   - 基本結合テスト実装（9テスト）
   - 状態管理統合テストの基盤整備

3. **コード構造整理完了**
   - 8セクションヘッダー追加完了
   - 依存関係順序での関数配置完了
   - 152テスト全通過確認

#### 品質指標達成
- **総テスト数**: 103 → 152テスト（+49テスト、47%増）
- **Unit Test実装率**: 2.5% → 50%（20倍向上）
- **テスト成功率**: 100%（152/152）
- **分割準備**: 8セクション構造整理完了

### Phase 4実行中: JavaScript分割とコンパイル環境構築

#### 完了した分割作業
1. **src-modules/ ディレクトリ構造作成完了**
   - 9個のモジュールフォルダ作成
   - 依存関係順序に基づく分割計画策定

2. **基本モジュール作成完了** (5/9)
   - ✅ core/utils.js: 基本機能・ユーティリティ (257行)
   - ✅ state/manager.js: 状態管理オブジェクト (125行)  
   - ✅ cache/manager.js: キャッシュ・永続化システム (150行)
   - ✅ dom/selectors.js: DOM要素セレクタ・検索 (140行)
   - ✅ pavilion/search.js: パビリオン検索機能 (180行)

### Phase 4完了: JavaScript分割とコンパイル環境構築成功 ✅

#### 完了した全作業
✅ **9つのモジュール分割完了** (100%)
✅ **webpack + Babel環境構築完了**
✅ **コンパイル・結合テスト成功**
✅ **152テスト全通過維持** (100%互換性確認)

#### 最終成果
- **分割モジュール数**: 9個
- **コンパイル済みファイル**: src/index-compiled.js (2,300行)
- **テスト結果**: 152/152 通過 (100%成功率)
- **技術スタック**: ES6 modules + webpack + Babel
- **依存関係管理**: 完全なモジュール分離

#### 技術的考慮事項
- ES6 modules (import/export) 使用
- 依存関係の明示的管理
- UserScript互換性維持のためのIIFE包装設定

---

## 現在の作業: セクション別分割作業（手順標準化版）

### セクション分割の標準手順

#### 1. 分割前の準備
- 元ファイル: `src/index-original.js` を基準とする
- 分割対象セクションの正確な行数範囲を確認する

#### 2. 2つのファイル作成
```bash
# 元ファイルを複製して2つのファイルを作成
cp src/index-original.js src-modules/sectionX.js  # セクションX用
cp src/index-original.js src-modules/main.js      # それ以外用（既存の場合は更新）
```

#### 3. 範囲による正確な分割
- **sectionX.js**: セクションXのみ残す（指定行数範囲のみ保持）
- **main.js**: セクションXを削除（指定行数範囲を除去）
- **重要**: 元のコード内容は一切変更しない

#### 4. import/export関係の調整

##### 4.1 sectionX.jsの調整
- 必要な関数にexport文を追加
- 他セクションの関数を使用している場合、適切なimport文を追加

##### 4.2 main.jsの調整
- sectionXから使用される関数をimportに追加
- sectionXが他セクションの関数を使う場合、その関数にexport文を追加

##### 4.3 既存分割ファイルの修正（重要）
- **新しいセクション分割により、import元がmain.js以外になる場合の対応**
- 例: section1.jsがsection2の関数を使用している場合
  - 従来: `import { func } from './main.js'`
  - 修正後: `import { func } from './section2.js'`
- **すべての既存分割ファイルのimport文を確認・修正する**

#### 5. webpack設定更新
- エントリーポイントがmain.jsを指していることを確認
- 必要に応じて設定を更新

#### 6. コンパイル確認
```bash
mise run build
```
- コンパイルエラーがないことを確認
- 生成されたindex.jsのサイズが適切であることを確認

### 循環依存の回避
- sectionX → main.js → sectionX の循環を避ける
- 依存関係は一方向に保つ
- 必要に応じて依存関係を整理する

### 注意事項
- **元のコード動作を完全に保持する**
- **import/export以外の変更は絶対に行わない**
- **正確な行数での分割を行う**
- **すべての依存関係を正しく解決する**

### 現在の進捗
- [x] セクション1分割完了（基本機能・ユーティリティ：13-498行目）
- [ ] セクション2分割
- [ ] セクション3分割
- [ ] セクション4分割
- [ ] セクション5分割
- [ ] セクション6分割
- [ ] セクション7分割
- [ ] セクション8分割

### 分割済みファイル構造
```
src-modules/
├── section1.js    # 基本機能・ユーティリティ（13-498行目）
└── main.js        # UserScriptヘッダー + セクション2以降
```